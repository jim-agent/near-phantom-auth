{"version":3,"sources":["../../src/server/db/adapters/postgres.ts","../../src/server/session.ts","../../src/server/passkey.ts","../../src/server/mpc.ts","../../src/server/recovery/wallet.ts","../../src/server/recovery/ipfs.ts","../../src/server/oauth/index.ts","../../src/server/oauth/router.ts","../../src/server/middleware.ts","../../src/server/codename.ts","../../src/server/router.ts","../../src/server/index.ts"],"names":["createHmac","randomUUID","generateRegistrationOptions","verifyRegistrationResponse","generateAuthenticationOptions","verifyAuthenticationResponse","createHash","randomBytes","nacl","bs58","promisify","scrypt","createCipheriv","createDecipheriv","Router","json","providerData"],"mappings":"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","file":"index.cjs","sourcesContent":["/**\n * PostgreSQL Database Adapter\n */\n\nimport type {\n  DatabaseAdapter,\n  AnonUser,\n  CreateUserInput,\n  OAuthUser,\n  CreateOAuthUserInput,\n  OAuthProvider,\n  Session,\n  CreateSessionInput,\n  Passkey,\n  CreatePasskeyInput,\n  Challenge,\n  RecoveryData,\n  RecoveryType,\n  AuthenticatorTransport,\n} from '../../../types/index.js';\n\nexport interface PostgresConfig {\n  connectionString: string;\n}\n\n/**\n * SQL schema for near-anon-auth tables\n */\nexport const POSTGRES_SCHEMA = `\n-- Anonymous users (HUMINT sources - passkey only)\nCREATE TABLE IF NOT EXISTS anon_users (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  codename TEXT UNIQUE NOT NULL,\n  near_account_id TEXT UNIQUE NOT NULL,\n  mpc_public_key TEXT NOT NULL,\n  derivation_path TEXT NOT NULL,\n  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  last_active_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\n-- OAuth users (standard users - OAuth providers)\nCREATE TABLE IF NOT EXISTS oauth_users (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  email TEXT UNIQUE NOT NULL,\n  name TEXT,\n  avatar_url TEXT,\n  near_account_id TEXT UNIQUE NOT NULL,\n  mpc_public_key TEXT NOT NULL,\n  derivation_path TEXT NOT NULL,\n  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  last_active_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\n-- OAuth provider connections\nCREATE TABLE IF NOT EXISTS oauth_providers (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL REFERENCES oauth_users(id) ON DELETE CASCADE,\n  provider TEXT NOT NULL,\n  provider_id TEXT NOT NULL,\n  email TEXT,\n  name TEXT,\n  avatar_url TEXT,\n  connected_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  UNIQUE(provider, provider_id)\n);\n\n-- Passkeys (WebAuthn credentials) - for anonymous users\nCREATE TABLE IF NOT EXISTS anon_passkeys (\n  credential_id TEXT PRIMARY KEY,\n  user_id UUID NOT NULL REFERENCES anon_users(id) ON DELETE CASCADE,\n  public_key BYTEA NOT NULL,\n  counter BIGINT NOT NULL DEFAULT 0,\n  device_type TEXT NOT NULL,\n  backed_up BOOLEAN NOT NULL DEFAULT false,\n  transports TEXT[],\n  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\n-- Sessions (works for both user types)\nCREATE TABLE IF NOT EXISTS anon_sessions (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL,\n  user_type TEXT NOT NULL DEFAULT 'anonymous',\n  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  expires_at TIMESTAMPTZ NOT NULL,\n  last_activity_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  ip_address TEXT,\n  user_agent TEXT\n);\n\n-- WebAuthn challenges (temporary)\nCREATE TABLE IF NOT EXISTS anon_challenges (\n  id UUID PRIMARY KEY,\n  challenge TEXT NOT NULL,\n  type TEXT NOT NULL,\n  user_id UUID,\n  expires_at TIMESTAMPTZ NOT NULL,\n  metadata JSONB\n);\n\n-- Recovery data references (works for both user types)\nCREATE TABLE IF NOT EXISTS anon_recovery (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL,\n  user_type TEXT NOT NULL DEFAULT 'anonymous',\n  type TEXT NOT NULL,\n  reference TEXT NOT NULL,\n  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  UNIQUE(user_id, type)\n);\n\n-- Indexes\nCREATE INDEX IF NOT EXISTS idx_anon_sessions_user ON anon_sessions(user_id);\nCREATE INDEX IF NOT EXISTS idx_anon_sessions_expires ON anon_sessions(expires_at);\nCREATE INDEX IF NOT EXISTS idx_anon_passkeys_user ON anon_passkeys(user_id);\nCREATE INDEX IF NOT EXISTS idx_anon_challenges_expires ON anon_challenges(expires_at);\nCREATE INDEX IF NOT EXISTS idx_oauth_users_email ON oauth_users(email);\nCREATE INDEX IF NOT EXISTS idx_oauth_providers_user ON oauth_providers(user_id);\nCREATE INDEX IF NOT EXISTS idx_oauth_providers_lookup ON oauth_providers(provider, provider_id);\n`;\n\n/**\n * Create PostgreSQL adapter\n * \n * Note: Requires 'pg' package to be installed by the consuming application\n */\nexport function createPostgresAdapter(config: PostgresConfig): DatabaseAdapter {\n  // Dynamic import of pg to make it optional\n  let pool: import('pg').Pool | null = null;\n  \n  async function getPool(): Promise<import('pg').Pool> {\n    if (!pool) {\n      const { Pool } = await import('pg');\n      pool = new Pool({ connectionString: config.connectionString });\n    }\n    return pool;\n  }\n\n  return {\n    async initialize() {\n      const p = await getPool();\n      await p.query(POSTGRES_SCHEMA);\n    },\n\n    async createUser(input: CreateUserInput): Promise<AnonUser> {\n      const p = await getPool();\n      const result = await p.query(\n        `INSERT INTO anon_users (codename, near_account_id, mpc_public_key, derivation_path)\n         VALUES ($1, $2, $3, $4)\n         RETURNING id, codename, near_account_id, mpc_public_key, derivation_path, created_at, last_active_at`,\n        [input.codename, input.nearAccountId, input.mpcPublicKey, input.derivationPath]\n      );\n      \n      const row = result.rows[0];\n      return {\n        id: row.id,\n        type: 'anonymous' as const,\n        codename: row.codename,\n        nearAccountId: row.near_account_id,\n        mpcPublicKey: row.mpc_public_key,\n        derivationPath: row.derivation_path,\n        createdAt: row.created_at,\n        lastActiveAt: row.last_active_at,\n      };\n    },\n\n    async getUserById(id: string): Promise<AnonUser | null> {\n      const p = await getPool();\n      const result = await p.query(\n        'SELECT * FROM anon_users WHERE id = $1',\n        [id]\n      );\n      \n      if (result.rows.length === 0) return null;\n      \n      const row = result.rows[0];\n      return {\n        id: row.id,\n        type: 'anonymous',\n        codename: row.codename,\n        nearAccountId: row.near_account_id,\n        mpcPublicKey: row.mpc_public_key,\n        derivationPath: row.derivation_path,\n        createdAt: row.created_at,\n        lastActiveAt: row.last_active_at,\n      };\n    },\n\n    async getUserByCodename(codename: string): Promise<AnonUser | null> {\n      const p = await getPool();\n      const result = await p.query(\n        'SELECT * FROM anon_users WHERE codename = $1',\n        [codename]\n      );\n      \n      if (result.rows.length === 0) return null;\n      \n      const row = result.rows[0];\n      return {\n        id: row.id,\n        type: 'anonymous',\n        codename: row.codename,\n        nearAccountId: row.near_account_id,\n        mpcPublicKey: row.mpc_public_key,\n        derivationPath: row.derivation_path,\n        createdAt: row.created_at,\n        lastActiveAt: row.last_active_at,\n      };\n    },\n\n    async getUserByNearAccount(nearAccountId: string): Promise<AnonUser | null> {\n      const p = await getPool();\n      const result = await p.query(\n        'SELECT * FROM anon_users WHERE near_account_id = $1',\n        [nearAccountId]\n      );\n      \n      if (result.rows.length === 0) return null;\n      \n      const row = result.rows[0];\n      return {\n        id: row.id,\n        type: 'anonymous',\n        codename: row.codename,\n        nearAccountId: row.near_account_id,\n        mpcPublicKey: row.mpc_public_key,\n        derivationPath: row.derivation_path,\n        createdAt: row.created_at,\n        lastActiveAt: row.last_active_at,\n      };\n    },\n\n    // ============================================\n    // OAuth Users\n    // ============================================\n\n    async createOAuthUser(input: CreateOAuthUserInput): Promise<OAuthUser> {\n      const p = await getPool();\n      const client = await p.connect();\n      \n      try {\n        await client.query('BEGIN');\n        \n        // Create user\n        const userResult = await client.query(\n          `INSERT INTO oauth_users (email, name, avatar_url, near_account_id, mpc_public_key, derivation_path)\n           VALUES ($1, $2, $3, $4, $5, $6)\n           RETURNING *`,\n          [input.email, input.name, input.avatarUrl, input.nearAccountId, input.mpcPublicKey, input.derivationPath]\n        );\n        \n        const userRow = userResult.rows[0];\n        \n        // Create provider connection\n        await client.query(\n          `INSERT INTO oauth_providers (user_id, provider, provider_id, email, name, avatar_url)\n           VALUES ($1, $2, $3, $4, $5, $6)`,\n          [\n            userRow.id,\n            input.provider.provider,\n            input.provider.providerId,\n            input.provider.email,\n            input.provider.name,\n            input.provider.avatarUrl,\n          ]\n        );\n        \n        await client.query('COMMIT');\n        \n        return {\n          id: userRow.id,\n          type: 'standard',\n          email: userRow.email,\n          name: userRow.name,\n          avatarUrl: userRow.avatar_url,\n          nearAccountId: userRow.near_account_id,\n          mpcPublicKey: userRow.mpc_public_key,\n          derivationPath: userRow.derivation_path,\n          providers: [input.provider],\n          createdAt: userRow.created_at,\n          lastActiveAt: userRow.last_active_at,\n        };\n      } catch (error) {\n        await client.query('ROLLBACK');\n        throw error;\n      } finally {\n        client.release();\n      }\n    },\n\n    async getOAuthUserById(id: string): Promise<OAuthUser | null> {\n      const p = await getPool();\n      const userResult = await p.query(\n        'SELECT * FROM oauth_users WHERE id = $1',\n        [id]\n      );\n      \n      if (userResult.rows.length === 0) return null;\n      \n      const userRow = userResult.rows[0];\n      \n      // Get providers\n      const providersResult = await p.query(\n        'SELECT * FROM oauth_providers WHERE user_id = $1',\n        [id]\n      );\n      \n      const providers: OAuthProvider[] = providersResult.rows.map((row: Record<string, unknown>) => ({\n        provider: row.provider as 'google' | 'github' | 'twitter',\n        providerId: row.provider_id as string,\n        email: row.email as string | undefined,\n        name: row.name as string | undefined,\n        avatarUrl: row.avatar_url as string | undefined,\n        connectedAt: row.connected_at as Date,\n      }));\n      \n      return {\n        id: userRow.id,\n        type: 'standard',\n        email: userRow.email,\n        name: userRow.name,\n        avatarUrl: userRow.avatar_url,\n        nearAccountId: userRow.near_account_id,\n        mpcPublicKey: userRow.mpc_public_key,\n        derivationPath: userRow.derivation_path,\n        providers,\n        createdAt: userRow.created_at,\n        lastActiveAt: userRow.last_active_at,\n      };\n    },\n\n    async getOAuthUserByEmail(email: string): Promise<OAuthUser | null> {\n      const p = await getPool();\n      const userResult = await p.query(\n        'SELECT * FROM oauth_users WHERE email = $1',\n        [email]\n      );\n      \n      if (userResult.rows.length === 0) return null;\n      \n      const userRow = userResult.rows[0];\n      \n      // Get providers\n      const providersResult = await p.query(\n        'SELECT * FROM oauth_providers WHERE user_id = $1',\n        [userRow.id]\n      );\n      \n      const providers: OAuthProvider[] = providersResult.rows.map((row: Record<string, unknown>) => ({\n        provider: row.provider as 'google' | 'github' | 'twitter',\n        providerId: row.provider_id as string,\n        email: row.email as string | undefined,\n        name: row.name as string | undefined,\n        avatarUrl: row.avatar_url as string | undefined,\n        connectedAt: row.connected_at as Date,\n      }));\n      \n      return {\n        id: userRow.id,\n        type: 'standard',\n        email: userRow.email,\n        name: userRow.name,\n        avatarUrl: userRow.avatar_url,\n        nearAccountId: userRow.near_account_id,\n        mpcPublicKey: userRow.mpc_public_key,\n        derivationPath: userRow.derivation_path,\n        providers,\n        createdAt: userRow.created_at,\n        lastActiveAt: userRow.last_active_at,\n      };\n    },\n\n    async getOAuthUserByProvider(provider: string, providerId: string): Promise<OAuthUser | null> {\n      const p = await getPool();\n      const providerResult = await p.query(\n        'SELECT user_id FROM oauth_providers WHERE provider = $1 AND provider_id = $2',\n        [provider, providerId]\n      );\n      \n      if (providerResult.rows.length === 0) return null;\n      \n      const userId = providerResult.rows[0].user_id;\n      return this.getOAuthUserById(userId);\n    },\n\n    async linkOAuthProvider(userId: string, provider: OAuthProvider): Promise<void> {\n      const p = await getPool();\n      await p.query(\n        `INSERT INTO oauth_providers (user_id, provider, provider_id, email, name, avatar_url)\n         VALUES ($1, $2, $3, $4, $5, $6)\n         ON CONFLICT (provider, provider_id) DO UPDATE SET\n           email = EXCLUDED.email,\n           name = EXCLUDED.name,\n           avatar_url = EXCLUDED.avatar_url`,\n        [\n          userId,\n          provider.provider,\n          provider.providerId,\n          provider.email,\n          provider.name,\n          provider.avatarUrl,\n        ]\n      );\n    },\n\n    async createPasskey(input: CreatePasskeyInput): Promise<Passkey> {\n      const p = await getPool();\n      await p.query(\n        `INSERT INTO anon_passkeys (credential_id, user_id, public_key, counter, device_type, backed_up, transports)\n         VALUES ($1, $2, $3, $4, $5, $6, $7)`,\n        [\n          input.credentialId,\n          input.userId,\n          input.publicKey,\n          input.counter,\n          input.deviceType,\n          input.backedUp,\n          input.transports || null,\n        ]\n      );\n      \n      return {\n        ...input,\n        createdAt: new Date(),\n      };\n    },\n\n    async getPasskeyById(credentialId: string): Promise<Passkey | null> {\n      const p = await getPool();\n      const result = await p.query(\n        'SELECT * FROM anon_passkeys WHERE credential_id = $1',\n        [credentialId]\n      );\n      \n      if (result.rows.length === 0) return null;\n      \n      const row = result.rows[0];\n      return {\n        credentialId: row.credential_id,\n        userId: row.user_id,\n        publicKey: row.public_key,\n        counter: row.counter,\n        deviceType: row.device_type,\n        backedUp: row.backed_up,\n        transports: row.transports,\n        createdAt: row.created_at,\n      };\n    },\n\n    async getPasskeysByUserId(userId: string): Promise<Passkey[]> {\n      const p = await getPool();\n      const result = await p.query(\n        'SELECT * FROM anon_passkeys WHERE user_id = $1',\n        [userId]\n      );\n      \n      return result.rows.map((row: Record<string, unknown>) => ({\n        credentialId: row.credential_id as string,\n        userId: row.user_id as string,\n        publicKey: row.public_key as Uint8Array,\n        counter: row.counter as number,\n        deviceType: row.device_type as 'singleDevice' | 'multiDevice',\n        backedUp: row.backed_up as boolean,\n        transports: row.transports as AuthenticatorTransport[] | undefined,\n        createdAt: row.created_at as Date,\n      }));\n    },\n\n    async updatePasskeyCounter(credentialId: string, counter: number): Promise<void> {\n      const p = await getPool();\n      await p.query(\n        'UPDATE anon_passkeys SET counter = $1 WHERE credential_id = $2',\n        [counter, credentialId]\n      );\n    },\n\n    async deletePasskey(credentialId: string): Promise<void> {\n      const p = await getPool();\n      await p.query('DELETE FROM anon_passkeys WHERE credential_id = $1', [credentialId]);\n    },\n\n    async createSession(input: CreateSessionInput & { id?: string }): Promise<Session> {\n      const p = await getPool();\n      const result = await p.query(\n        `INSERT INTO anon_sessions (id, user_id, expires_at, ip_address, user_agent)\n         VALUES (COALESCE($1, gen_random_uuid()), $2, $3, $4, $5)\n         RETURNING id, user_id, created_at, expires_at, last_activity_at, ip_address, user_agent`,\n        [input.id || null, input.userId, input.expiresAt, input.ipAddress || null, input.userAgent || null]\n      );\n      \n      const row = result.rows[0];\n      return {\n        id: row.id,\n        userId: row.user_id,\n        createdAt: row.created_at,\n        expiresAt: row.expires_at,\n        lastActivityAt: row.last_activity_at,\n        ipAddress: row.ip_address,\n        userAgent: row.user_agent,\n      };\n    },\n\n    async getSession(sessionId: string): Promise<Session | null> {\n      const p = await getPool();\n      const result = await p.query(\n        'SELECT * FROM anon_sessions WHERE id = $1 AND expires_at > NOW()',\n        [sessionId]\n      );\n      \n      if (result.rows.length === 0) return null;\n      \n      const row = result.rows[0];\n      return {\n        id: row.id,\n        userId: row.user_id,\n        createdAt: row.created_at,\n        expiresAt: row.expires_at,\n        lastActivityAt: row.last_activity_at,\n        ipAddress: row.ip_address,\n        userAgent: row.user_agent,\n      };\n    },\n\n    async deleteSession(sessionId: string): Promise<void> {\n      const p = await getPool();\n      await p.query('DELETE FROM anon_sessions WHERE id = $1', [sessionId]);\n    },\n\n    async deleteUserSessions(userId: string): Promise<void> {\n      const p = await getPool();\n      await p.query('DELETE FROM anon_sessions WHERE user_id = $1', [userId]);\n    },\n\n    async cleanExpiredSessions(): Promise<number> {\n      const p = await getPool();\n      const result = await p.query('DELETE FROM anon_sessions WHERE expires_at < NOW()');\n      return result.rowCount || 0;\n    },\n\n    async storeChallenge(challenge: Challenge): Promise<void> {\n      const p = await getPool();\n      await p.query(\n        `INSERT INTO anon_challenges (id, challenge, type, user_id, expires_at, metadata)\n         VALUES ($1, $2, $3, $4, $5, $6)`,\n        [\n          challenge.id,\n          challenge.challenge,\n          challenge.type,\n          challenge.userId || null,\n          challenge.expiresAt,\n          challenge.metadata ? JSON.stringify(challenge.metadata) : null,\n        ]\n      );\n    },\n\n    async getChallenge(challengeId: string): Promise<Challenge | null> {\n      const p = await getPool();\n      const result = await p.query(\n        'SELECT * FROM anon_challenges WHERE id = $1',\n        [challengeId]\n      );\n      \n      if (result.rows.length === 0) return null;\n      \n      const row = result.rows[0];\n      return {\n        id: row.id,\n        challenge: row.challenge,\n        type: row.type,\n        userId: row.user_id,\n        expiresAt: row.expires_at,\n        metadata: row.metadata,\n      };\n    },\n\n    async deleteChallenge(challengeId: string): Promise<void> {\n      const p = await getPool();\n      await p.query('DELETE FROM anon_challenges WHERE id = $1', [challengeId]);\n    },\n\n    async storeRecoveryData(data: RecoveryData): Promise<void> {\n      const p = await getPool();\n      await p.query(\n        `INSERT INTO anon_recovery (user_id, type, reference)\n         VALUES ($1, $2, $3)\n         ON CONFLICT (user_id, type) DO UPDATE SET reference = $3, created_at = NOW()`,\n        [data.userId, data.type, data.reference]\n      );\n    },\n\n    async getRecoveryData(userId: string, type: RecoveryType): Promise<RecoveryData | null> {\n      const p = await getPool();\n      const result = await p.query(\n        'SELECT * FROM anon_recovery WHERE user_id = $1 AND type = $2',\n        [userId, type]\n      );\n      \n      if (result.rows.length === 0) return null;\n      \n      const row = result.rows[0];\n      return {\n        userId: row.user_id,\n        type: row.type,\n        reference: row.reference,\n        createdAt: row.created_at,\n      };\n    },\n  };\n}\n","/**\n * Session Management\n * \n * HttpOnly cookie-based sessions for XSS protection.\n * Sessions are stored server-side (database) with secure cookie reference.\n */\n\nimport { randomUUID, createHmac } from 'crypto';\nimport type { Response, Request } from 'express';\nimport type { Session, CreateSessionInput, DatabaseAdapter } from '../types/index.js';\n\nconst SESSION_COOKIE_NAME = 'anon_session';\nconst DEFAULT_SESSION_DURATION_MS = 7 * 24 * 60 * 60 * 1000; // 7 days\n\nexport interface SessionConfig {\n  /** Secret for signing session cookies */\n  secret: string;\n  /** Cookie name (default: anon_session) */\n  cookieName?: string;\n  /** Session duration in ms (default: 7 days) */\n  durationMs?: number;\n  /** Cookie domain (optional) */\n  domain?: string;\n  /** Cookie path (default: /) */\n  path?: string;\n  /** Secure flag (default: true in production) */\n  secure?: boolean;\n  /** SameSite setting (default: strict) */\n  sameSite?: 'strict' | 'lax' | 'none';\n}\n\nexport interface SessionManager {\n  createSession(\n    userId: string,\n    res: Response,\n    options?: { ipAddress?: string; userAgent?: string }\n  ): Promise<Session>;\n  \n  getSession(req: Request): Promise<Session | null>;\n  \n  destroySession(req: Request, res: Response): Promise<void>;\n  \n  refreshSession(req: Request, res: Response): Promise<Session | null>;\n}\n\n/**\n * Sign a session ID with HMAC\n */\nfunction signSessionId(sessionId: string, secret: string): string {\n  const signature = createHmac('sha256', secret)\n    .update(sessionId)\n    .digest('base64url');\n  return `${sessionId}.${signature}`;\n}\n\n/**\n * Verify and extract session ID from signed value\n */\nfunction verifySessionId(signedValue: string, secret: string): string | null {\n  const parts = signedValue.split('.');\n  if (parts.length !== 2) return null;\n  \n  const [sessionId, signature] = parts;\n  const expectedSignature = createHmac('sha256', secret)\n    .update(sessionId)\n    .digest('base64url');\n  \n  if (signature !== expectedSignature) return null;\n  return sessionId;\n}\n\n/**\n * Parse cookies from request\n */\nfunction parseCookies(req: Request): Record<string, string> {\n  const cookies: Record<string, string> = {};\n  const cookieHeader = req.headers.cookie;\n  \n  if (!cookieHeader) return cookies;\n  \n  cookieHeader.split(';').forEach((cookie) => {\n    const [name, ...rest] = cookie.trim().split('=');\n    if (name && rest.length) {\n      cookies[name] = decodeURIComponent(rest.join('='));\n    }\n  });\n  \n  return cookies;\n}\n\n/**\n * Create session manager\n */\nexport function createSessionManager(\n  db: DatabaseAdapter,\n  config: SessionConfig\n): SessionManager {\n  const cookieName = config.cookieName || SESSION_COOKIE_NAME;\n  const durationMs = config.durationMs || DEFAULT_SESSION_DURATION_MS;\n  const isProduction = process.env.NODE_ENV === 'production';\n  \n  const cookieOptions = {\n    httpOnly: true,\n    secure: config.secure ?? isProduction,\n    sameSite: config.sameSite || 'strict',\n    path: config.path || '/',\n    domain: config.domain,\n  };\n\n  return {\n    async createSession(userId, res, options = {}) {\n      const sessionId = randomUUID();\n      const now = new Date();\n      const expiresAt = new Date(now.getTime() + durationMs);\n      \n      const sessionInput: CreateSessionInput = {\n        userId,\n        expiresAt,\n        ipAddress: options.ipAddress,\n        userAgent: options.userAgent,\n      };\n      \n      const session = await db.createSession({\n        ...sessionInput,\n        id: sessionId,\n      } as Session);\n      \n      // Sign and set cookie\n      const signedId = signSessionId(sessionId, config.secret);\n      \n      res.cookie(cookieName, signedId, {\n        ...cookieOptions,\n        maxAge: durationMs,\n        expires: expiresAt,\n      });\n      \n      return session;\n    },\n    \n    async getSession(req) {\n      const cookies = parseCookies(req);\n      const signedId = cookies[cookieName];\n      \n      if (!signedId) return null;\n      \n      const sessionId = verifySessionId(signedId, config.secret);\n      if (!sessionId) return null;\n      \n      const session = await db.getSession(sessionId);\n      \n      if (!session) return null;\n      \n      // Check if expired\n      if (session.expiresAt < new Date()) {\n        await db.deleteSession(sessionId);\n        return null;\n      }\n      \n      return session;\n    },\n    \n    async destroySession(req, res) {\n      const cookies = parseCookies(req);\n      const signedId = cookies[cookieName];\n      \n      if (signedId) {\n        const sessionId = verifySessionId(signedId, config.secret);\n        if (sessionId) {\n          await db.deleteSession(sessionId);\n        }\n      }\n      \n      // Clear cookie\n      res.clearCookie(cookieName, {\n        ...cookieOptions,\n      });\n    },\n    \n    async refreshSession(req, res) {\n      const session = await this.getSession(req);\n      \n      if (!session) return null;\n      \n      // Check if session is past 50% of its lifetime (sliding window)\n      const now = Date.now();\n      const created = session.createdAt.getTime();\n      const expires = session.expiresAt.getTime();\n      const lifetime = expires - created;\n      const elapsed = now - created;\n      \n      if (elapsed > lifetime * 0.5) {\n        // Extend session\n        const newExpiresAt = new Date(now + durationMs);\n        \n        // Update in database would happen here\n        // For now, just update cookie\n        const signedId = signSessionId(session.id, config.secret);\n        \n        res.cookie(cookieName, signedId, {\n          ...cookieOptions,\n          maxAge: durationMs,\n          expires: newExpiresAt,\n        });\n      }\n      \n      return session;\n    },\n  };\n}\n","/**\n * Passkey (WebAuthn) Authentication\n * \n * Handles passkey registration and authentication using @simplewebauthn/server\n */\n\nimport {\n  generateRegistrationOptions,\n  verifyRegistrationResponse,\n  generateAuthenticationOptions,\n  verifyAuthenticationResponse,\n} from '@simplewebauthn/server';\nimport type {\n  GenerateRegistrationOptionsOpts,\n  GenerateAuthenticationOptionsOpts,\n  VerifyRegistrationResponseOpts,\n  VerifyAuthenticationResponseOpts,\n  VerifiedRegistrationResponse,\n  VerifiedAuthenticationResponse,\n} from '@simplewebauthn/server';\nimport { randomUUID } from 'crypto';\nimport type {\n  DatabaseAdapter,\n  Challenge,\n  Passkey,\n  CreatePasskeyInput,\n  PublicKeyCredentialCreationOptionsJSON,\n  PublicKeyCredentialRequestOptionsJSON,\n  RegistrationResponseJSON,\n  AuthenticationResponseJSON,\n  AuthenticatorTransport,\n} from '../types/index.js';\n\nexport interface PasskeyConfig {\n  /** Relying Party name (shown to users) */\n  rpName: string;\n  /** Relying Party ID (your domain, e.g., 'example.com') */\n  rpId: string;\n  /** Origin for WebAuthn (e.g., 'https://example.com') */\n  origin: string;\n  /** Challenge timeout in ms (default: 60000) */\n  challengeTimeoutMs?: number;\n}\n\nexport interface PasskeyManager {\n  startRegistration(\n    userId: string,\n    userDisplayName: string\n  ): Promise<{\n    challengeId: string;\n    options: PublicKeyCredentialCreationOptionsJSON;\n  }>;\n  \n  finishRegistration(\n    challengeId: string,\n    response: RegistrationResponseJSON\n  ): Promise<{\n    verified: boolean;\n    passkeyData?: {\n      credentialId: string;\n      publicKey: Uint8Array;\n      counter: number;\n      deviceType: 'singleDevice' | 'multiDevice';\n      backedUp: boolean;\n      transports?: AuthenticatorTransport[];\n    };\n    tempUserId?: string;\n  }>;\n  \n  startAuthentication(\n    userId?: string\n  ): Promise<{\n    challengeId: string;\n    options: PublicKeyCredentialRequestOptionsJSON;\n  }>;\n  \n  finishAuthentication(\n    challengeId: string,\n    response: AuthenticationResponseJSON\n  ): Promise<{\n    verified: boolean;\n    userId?: string;\n    passkey?: Passkey;\n  }>;\n}\n\n/**\n * Create passkey manager\n */\nexport function createPasskeyManager(\n  db: DatabaseAdapter,\n  config: PasskeyConfig\n): PasskeyManager {\n  const challengeTimeoutMs = config.challengeTimeoutMs || 60000;\n\n  return {\n    async startRegistration(userId, userDisplayName) {\n      // For registration, userId is a temp ID - user doesn't exist yet\n      // We store it in metadata, not as a foreign key\n      \n      const options = await generateRegistrationOptions({\n        rpName: config.rpName,\n        rpID: config.rpId,\n        userName: userDisplayName,\n        userDisplayName: userDisplayName,\n        userID: new TextEncoder().encode(userId),\n        attestationType: 'none',\n        excludeCredentials: [], // No existing passkeys for new user\n        authenticatorSelection: {\n          residentKey: 'preferred',\n          userVerification: 'preferred',\n          authenticatorAttachment: 'platform',\n        },\n      } as GenerateRegistrationOptionsOpts);\n      \n      // Store challenge - userId goes in metadata since user doesn't exist yet\n      const challengeId = randomUUID();\n      const challenge: Challenge = {\n        id: challengeId,\n        challenge: options.challenge,\n        type: 'registration',\n        userId: undefined, // Don't set foreign key - user doesn't exist\n        expiresAt: new Date(Date.now() + challengeTimeoutMs),\n        metadata: { tempUserId: userId, userDisplayName }, // Store temp ID here\n      };\n      \n      await db.storeChallenge(challenge);\n      \n      return {\n        challengeId,\n        options: options as unknown as PublicKeyCredentialCreationOptionsJSON,\n      };\n    },\n    \n    async finishRegistration(challengeId, response) {\n      // Get and validate challenge\n      const challenge = await db.getChallenge(challengeId);\n      \n      if (!challenge) {\n        throw new Error('Challenge not found or expired');\n      }\n      \n      if (challenge.type !== 'registration') {\n        throw new Error('Invalid challenge type');\n      }\n      \n      if (challenge.expiresAt < new Date()) {\n        await db.deleteChallenge(challengeId);\n        throw new Error('Challenge expired');\n      }\n      \n      // Get temp user ID from metadata (for registration, user doesn't exist yet)\n      const tempUserId = challenge.metadata?.tempUserId as string | undefined;\n      if (!tempUserId) {\n        throw new Error('Challenge missing temp user ID');\n      }\n      \n      // Verify registration\n      let verification: VerifiedRegistrationResponse;\n      try {\n        verification = await verifyRegistrationResponse({\n          response: response as unknown as Parameters<typeof verifyRegistrationResponse>[0]['response'],\n          expectedChallenge: challenge.challenge,\n          expectedOrigin: config.origin,\n          expectedRPID: config.rpId,\n        } as VerifyRegistrationResponseOpts);\n      } catch (error) {\n        console.error('[Passkey] Registration verification failed:', error);\n        await db.deleteChallenge(challengeId);\n        return { verified: false };\n      }\n      \n      if (!verification.verified || !verification.registrationInfo) {\n        await db.deleteChallenge(challengeId);\n        return { verified: false };\n      }\n      \n      const { registrationInfo } = verification;\n      \n      // Clean up challenge\n      await db.deleteChallenge(challengeId);\n      \n      // Return verified data - caller must create user first, then passkey\n      // We return the passkey data but don't save it yet (user doesn't exist)\n      return {\n        verified: true,\n        passkeyData: {\n          credentialId: registrationInfo.credential.id,\n          publicKey: registrationInfo.credential.publicKey,\n          counter: registrationInfo.credential.counter,\n          deviceType: registrationInfo.credentialDeviceType,\n          backedUp: registrationInfo.credentialBackedUp,\n          transports: response.response.transports,\n        },\n        tempUserId,\n      };\n    },\n    \n    async startAuthentication(userId) {\n      // Get user's passkeys if userId provided\n      let allowCredentials: Array<{\n        id: string;\n        type: 'public-key';\n        transports?: AuthenticatorTransport[];\n      }> | undefined;\n      \n      if (userId) {\n        const passkeys = await db.getPasskeysByUserId(userId);\n        allowCredentials = passkeys.map((pk) => ({\n          id: pk.credentialId,\n          type: 'public-key' as const,\n          transports: pk.transports,\n        }));\n      }\n      \n      const options = await generateAuthenticationOptions({\n        rpID: config.rpId,\n        userVerification: 'preferred',\n        allowCredentials,\n      } as GenerateAuthenticationOptionsOpts);\n      \n      // Store challenge\n      const challengeId = randomUUID();\n      const challenge: Challenge = {\n        id: challengeId,\n        challenge: options.challenge,\n        type: 'authentication',\n        userId,\n        expiresAt: new Date(Date.now() + challengeTimeoutMs),\n      };\n      \n      await db.storeChallenge(challenge);\n      \n      return {\n        challengeId,\n        options: options as unknown as PublicKeyCredentialRequestOptionsJSON,\n      };\n    },\n    \n    async finishAuthentication(challengeId, response) {\n      // Get and validate challenge\n      const challenge = await db.getChallenge(challengeId);\n      \n      if (!challenge) {\n        throw new Error('Challenge not found or expired');\n      }\n      \n      if (challenge.type !== 'authentication') {\n        throw new Error('Invalid challenge type');\n      }\n      \n      if (challenge.expiresAt < new Date()) {\n        await db.deleteChallenge(challengeId);\n        throw new Error('Challenge expired');\n      }\n      \n      // Find passkey by credential ID\n      const passkey = await db.getPasskeyById(response.id);\n      \n      if (!passkey) {\n        await db.deleteChallenge(challengeId);\n        throw new Error('Passkey not found');\n      }\n      \n      // Verify authentication\n      let verification: VerifiedAuthenticationResponse;\n      try {\n        verification = await verifyAuthenticationResponse({\n          response: response as unknown as Parameters<typeof verifyAuthenticationResponse>[0]['response'],\n          expectedChallenge: challenge.challenge,\n          expectedOrigin: config.origin,\n          expectedRPID: config.rpId,\n          credential: {\n            id: passkey.credentialId,\n            publicKey: passkey.publicKey,\n            counter: passkey.counter,\n            transports: passkey.transports,\n          },\n        } as VerifyAuthenticationResponseOpts);\n      } catch (error) {\n        console.error('[Passkey] Authentication verification failed:', error);\n        await db.deleteChallenge(challengeId);\n        return { verified: false };\n      }\n      \n      if (!verification.verified) {\n        await db.deleteChallenge(challengeId);\n        return { verified: false };\n      }\n      \n      // Update counter\n      await db.updatePasskeyCounter(\n        passkey.credentialId,\n        verification.authenticationInfo.newCounter\n      );\n      \n      // Clean up challenge\n      await db.deleteChallenge(challengeId);\n      \n      return {\n        verified: true,\n        userId: passkey.userId,\n        passkey,\n      };\n    },\n  };\n}\n","/**\n * NEAR MPC Account Manager\n * \n * Creates NEAR accounts using Chain Signatures MPC network.\n * No private keys are stored - all key management is decentralized.\n */\n\nimport { createHash, randomBytes } from 'crypto';\n\nexport interface MPCAccount {\n  nearAccountId: string;\n  derivationPath: string;\n  mpcPublicKey: string;\n  onChain: boolean;\n}\n\nexport interface MPCConfig {\n  networkId: 'testnet' | 'mainnet';\n  accountPrefix?: string;\n  treasuryAccount?: string;\n  treasuryPrivateKey?: string;\n  fundingAmount?: string; // in NEAR, default 0.01\n}\n\n/**\n * Get the MPC contract ID for a network\n */\nfunction getMPCContractId(networkId: 'testnet' | 'mainnet'): string {\n  return networkId === 'mainnet'\n    ? 'v1.signer-prod.near'\n    : 'v1.signer-prod.testnet';\n}\n\n/**\n * Get the RPC URL for a network\n */\nfunction getRPCUrl(networkId: 'testnet' | 'mainnet'): string {\n  return networkId === 'mainnet'\n    ? 'https://rpc.mainnet.near.org'\n    : 'https://rpc.testnet.near.org';\n}\n\n/**\n * Base58 encode bytes\n */\nfunction base58Encode(bytes: Buffer): string {\n  const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n  let result = '';\n  let num = BigInt('0x' + bytes.toString('hex'));\n\n  while (num > 0n) {\n    const remainder = Number(num % 58n);\n    num = num / 58n;\n    result = ALPHABET[remainder] + result;\n  }\n\n  // Handle leading zeros\n  for (const byte of bytes) {\n    if (byte === 0) {\n      result = '1' + result;\n    } else {\n      break;\n    }\n  }\n\n  return result || '1';\n}\n\n/**\n * Derive Ed25519 public key from seed (simplified for account creation)\n */\nfunction derivePublicKey(seed: Buffer): Buffer {\n  const hash = createHash('sha512').update(seed).digest();\n  return hash.subarray(0, 32);\n}\n\n/**\n * Check if NEAR account exists on-chain\n */\nasync function accountExists(\n  accountId: string, \n  networkId: 'testnet' | 'mainnet'\n): Promise<boolean> {\n  try {\n    const rpcUrl = getRPCUrl(networkId);\n    const response = await fetch(rpcUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        jsonrpc: '2.0',\n        id: 'check-account',\n        method: 'query',\n        params: {\n          request_type: 'view_account',\n          finality: 'final',\n          account_id: accountId,\n        },\n      }),\n    });\n\n    const result = await response.json() as { error?: unknown };\n    return !result.error;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Create NEAR account on testnet using helper API\n */\nasync function createTestnetAccount(accountId: string): Promise<string> {\n  // Generate a random keypair for initial account access\n  const seed = randomBytes(32);\n  const publicKeyBytes = derivePublicKey(seed);\n  const publicKey = `ed25519:${base58Encode(publicKeyBytes)}`;\n\n  const helperUrl = 'https://helper.testnet.near.org/account';\n\n  const response = await fetch(helperUrl, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      newAccountId: accountId,\n      newAccountPublicKey: publicKey,\n    }),\n  });\n\n  if (!response.ok) {\n    const errorText = await response.text();\n    throw new Error(`Testnet helper error: ${response.status} - ${errorText}`);\n  }\n\n  return publicKey;\n}\n\n/**\n * Generate a deterministic account name from user ID\n */\nfunction generateAccountName(userId: string, prefix: string): string {\n  const hash = createHash('sha256').update(userId).digest('hex');\n  const shortHash = hash.substring(0, 12);\n  return `${prefix}-${shortHash}`;\n}\n\n/**\n * Fund an implicit account from treasury using NEAR RPC\n */\nasync function fundAccountFromTreasury(\n  accountId: string,\n  treasuryAccount: string,\n  treasuryPrivateKey: string,\n  amountNear: string,\n  networkId: 'testnet' | 'mainnet'\n): Promise<{ success: boolean; txHash?: string; error?: string }> {\n  // Dynamic import to avoid bundling issues\n  const nacl = await import('tweetnacl');\n  const bs58 = await import('bs58');\n  \n  try {\n    const rpcUrl = getRPCUrl(networkId);\n    \n    // Parse the private key (format: ed25519:BASE58_ENCODED_KEY)\n    const keyString = treasuryPrivateKey.replace('ed25519:', '');\n    let secretKey: Uint8Array;\n    \n    try {\n      // Try base58 decoding first (standard NEAR format)\n      secretKey = bs58.default.decode(keyString);\n    } catch {\n      // Fallback to base64\n      secretKey = Buffer.from(keyString, 'base64');\n    }\n    \n    // Extract public key from secret key\n    // NEAR uses 64-byte secret key where last 32 bytes are public key\n    const publicKey = secretKey.length === 64 \n      ? secretKey.slice(32) \n      : nacl.default.sign.keyPair.fromSeed(secretKey.slice(0, 32)).publicKey;\n    \n    const publicKeyB58 = bs58.default.encode(Buffer.from(publicKey));\n    const fullPublicKey = `ed25519:${publicKeyB58}`;\n    \n    console.log('[MPC] Treasury public key:', fullPublicKey);\n    \n    // Get access key for nonce and block hash\n    const accessKeyResponse = await fetch(rpcUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        jsonrpc: '2.0',\n        id: 'get-access-key',\n        method: 'query',\n        params: {\n          request_type: 'view_access_key',\n          finality: 'final',\n          account_id: treasuryAccount,\n          public_key: fullPublicKey,\n        },\n      }),\n    });\n    \n    const accessKeyResult = await accessKeyResponse.json() as {\n      result?: { nonce: number; block_hash: string };\n      error?: { cause?: { name: string }; message?: string };\n    };\n    \n    if (accessKeyResult.error || !accessKeyResult.result) {\n      console.error('[MPC] Access key error:', accessKeyResult.error);\n      return { \n        success: false, \n        error: `Could not get access key: ${accessKeyResult.error?.cause?.name || 'Unknown'}`,\n      };\n    }\n    \n    const nonce = accessKeyResult.result.nonce + 1;\n    const blockHash = accessKeyResult.result.block_hash;\n    \n    // Convert NEAR to yoctoNEAR (1 NEAR = 10^24 yoctoNEAR)\n    const amountYocto = BigInt(Math.floor(parseFloat(amountNear) * 1e24));\n    \n    // Build transaction manually using borsh serialization\n    // Transaction structure: signerId, publicKey, nonce, receiverId, blockHash, actions\n    const transaction = buildTransferTransaction(\n      treasuryAccount,\n      publicKey,\n      nonce,\n      accountId,\n      blockHash,\n      amountYocto,\n      bs58.default\n    );\n    \n    // Sign the transaction\n    const txHash = createHash('sha256').update(transaction).digest();\n    const signature = nacl.default.sign.detached(txHash, secretKey);\n    \n    // Build signed transaction\n    const signedTx = buildSignedTransaction(transaction, signature, publicKey);\n    \n    // Submit to RPC\n    const submitResponse = await fetch(rpcUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        jsonrpc: '2.0',\n        id: 'send-tx',\n        method: 'broadcast_tx_commit',\n        params: [Buffer.from(signedTx).toString('base64')],\n      }),\n    });\n    \n    const submitResult = await submitResponse.json() as {\n      result?: { transaction: { hash: string } };\n      error?: { data?: string; message?: string };\n    };\n    \n    if (submitResult.error) {\n      console.error('[MPC] Transaction error:', submitResult.error);\n      return { \n        success: false, \n        error: submitResult.error.data || submitResult.error.message || 'Transaction failed',\n      };\n    }\n    \n    const resultHash = submitResult.result?.transaction?.hash || 'unknown';\n    console.log('[MPC] Funded account:', accountId, 'txHash:', resultHash);\n    \n    return { success: true, txHash: resultHash };\n  } catch (error) {\n    console.error('[MPC] Treasury funding failed:', error);\n    return { \n      success: false, \n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Build a NEAR transfer transaction (borsh serialized)\n */\nfunction buildTransferTransaction(\n  signerId: string,\n  publicKey: Uint8Array,\n  nonce: number,\n  receiverId: string,\n  blockHash: string,\n  amount: bigint,\n  bs58: { decode: (str: string) => Uint8Array }\n): Uint8Array {\n  // Borsh serialize the transaction\n  const parts: Uint8Array[] = [];\n  \n  // signerId (string)\n  parts.push(serializeString(signerId));\n  \n  // publicKey (enum + data) - ED25519 = 0\n  parts.push(new Uint8Array([0])); // key type\n  parts.push(new Uint8Array(publicKey));\n  \n  // nonce (u64)\n  parts.push(serializeU64(BigInt(nonce)));\n  \n  // receiverId (string)\n  parts.push(serializeString(receiverId));\n  \n  // blockHash (32 bytes)\n  parts.push(bs58.decode(blockHash));\n  \n  // actions (vec of Action) - single Transfer action\n  parts.push(serializeU32(1)); // vec length\n  parts.push(new Uint8Array([3])); // Transfer action type\n  parts.push(serializeU128(amount)); // amount\n  \n  return concatArrays(parts);\n}\n\n/**\n * Build signed transaction\n */\nfunction buildSignedTransaction(\n  transaction: Uint8Array,\n  signature: Uint8Array,\n  publicKey: Uint8Array\n): Uint8Array {\n  const parts: Uint8Array[] = [];\n  \n  // Transaction bytes\n  parts.push(transaction);\n  \n  // Signature (enum + data) - ED25519 = 0\n  parts.push(new Uint8Array([0])); // signature type\n  parts.push(new Uint8Array(signature));\n  \n  return concatArrays(parts);\n}\n\n// Borsh serialization helpers\nfunction serializeString(str: string): Uint8Array {\n  const bytes = Buffer.from(str, 'utf8');\n  const len = serializeU32(bytes.length);\n  return concatArrays([len, bytes]);\n}\n\nfunction serializeU32(num: number): Uint8Array {\n  const buf = Buffer.alloc(4);\n  buf.writeUInt32LE(num);\n  return buf;\n}\n\nfunction serializeU64(num: bigint): Uint8Array {\n  const buf = Buffer.alloc(8);\n  buf.writeBigUInt64LE(num);\n  return buf;\n}\n\nfunction serializeU128(num: bigint): Uint8Array {\n  const buf = Buffer.alloc(16);\n  buf.writeBigUInt64LE(num & BigInt('0xFFFFFFFFFFFFFFFF'), 0);\n  buf.writeBigUInt64LE(num >> BigInt(64), 8);\n  return buf;\n}\n\nfunction concatArrays(arrays: Uint8Array[]): Uint8Array {\n  const totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const arr of arrays) {\n    result.set(arr, offset);\n    offset += arr.length;\n  }\n  return result;\n}\n\n/**\n * MPC Account Manager\n */\nexport class MPCAccountManager {\n  private networkId: 'testnet' | 'mainnet';\n  private mpcContractId: string;\n  private accountPrefix: string;\n  private treasuryAccount?: string;\n  private treasuryPrivateKey?: string;\n  private fundingAmount: string;\n\n  constructor(config: MPCConfig) {\n    this.networkId = config.networkId;\n    this.mpcContractId = getMPCContractId(config.networkId);\n    this.accountPrefix = config.accountPrefix || 'anon';\n    this.treasuryAccount = config.treasuryAccount;\n    this.treasuryPrivateKey = config.treasuryPrivateKey;\n    this.fundingAmount = config.fundingAmount || '0.01';\n  }\n\n  /**\n   * Create a new NEAR account for an anonymous user\n   */\n  async createAccount(userId: string): Promise<MPCAccount> {\n    const accountName = generateAccountName(userId, this.accountPrefix);\n    const suffix = this.networkId === 'mainnet' ? '.near' : '.testnet';\n    const nearAccountId = `${accountName}${suffix}`;\n\n    // Derivation path for MPC key generation\n    const derivationPath = `near-anon-auth,${userId}`;\n\n    console.log('[MPC] Creating NEAR account:', {\n      nearAccountId,\n      derivationPath,\n      mpcContractId: this.mpcContractId,\n    });\n\n    // Check if account already exists\n    const exists = await accountExists(nearAccountId, this.networkId);\n    if (exists) {\n      console.log('[MPC] Account already exists:', nearAccountId);\n      return {\n        nearAccountId,\n        derivationPath,\n        mpcPublicKey: 'existing-account',\n        onChain: true,\n      };\n    }\n\n    // Create account on testnet\n    if (this.networkId === 'testnet') {\n      try {\n        const publicKey = await createTestnetAccount(nearAccountId);\n        console.log('[MPC] Account created:', nearAccountId);\n        \n        return {\n          nearAccountId,\n          derivationPath,\n          mpcPublicKey: publicKey,\n          onChain: true,\n        };\n      } catch (error) {\n        console.error('[MPC] Account creation failed:', error);\n        return {\n          nearAccountId,\n          derivationPath,\n          mpcPublicKey: 'creation-failed',\n          onChain: false,\n        };\n      }\n    }\n\n    // Mainnet: Use implicit accounts\n    // Implicit account ID = hex of public key (64 chars)\n    try {\n      const seed = createHash('sha256').update(`implicit-${userId}`).digest();\n      const publicKeyBytes = derivePublicKey(seed);\n      const implicitAccountId = publicKeyBytes.toString('hex');\n      const publicKey = `ed25519:${base58Encode(publicKeyBytes)}`;\n      \n      console.log('[MPC] Created mainnet implicit account:', implicitAccountId);\n      \n      // Check if account already funded/exists\n      const alreadyExists = await accountExists(implicitAccountId, this.networkId);\n      if (alreadyExists) {\n        console.log('[MPC] Implicit account already funded:', implicitAccountId);\n        return {\n          nearAccountId: implicitAccountId,\n          derivationPath,\n          mpcPublicKey: publicKey,\n          onChain: true,\n        };\n      }\n      \n      // Fund the account from treasury if configured\n      let onChain = false;\n      if (this.treasuryAccount && this.treasuryPrivateKey) {\n        console.log('[MPC] Funding implicit account from treasury...');\n        const fundResult = await fundAccountFromTreasury(\n          implicitAccountId,\n          this.treasuryAccount,\n          this.treasuryPrivateKey,\n          this.fundingAmount,\n          this.networkId\n        );\n        \n        if (fundResult.success) {\n          console.log('[MPC] Account funded:', fundResult.txHash);\n          onChain = true;\n        } else {\n          console.warn('[MPC] Funding failed, account will be dormant:', fundResult.error);\n        }\n      } else {\n        console.warn('[MPC] No treasury configured, account will be dormant until funded');\n      }\n      \n      return {\n        nearAccountId: implicitAccountId,\n        derivationPath,\n        mpcPublicKey: publicKey,\n        onChain,\n      };\n    } catch (error) {\n      console.error('[MPC] Mainnet implicit account creation failed:', error);\n      return {\n        nearAccountId,\n        derivationPath,\n        mpcPublicKey: 'creation-failed',\n        onChain: false,\n      };\n    }\n  }\n\n  /**\n   * Add a recovery wallet as an access key to the MPC account\n   * \n   * This creates an on-chain link without storing it in our database.\n   * The recovery wallet can be used to prove ownership and create new passkeys.\n   */\n  async addRecoveryWallet(\n    nearAccountId: string,\n    recoveryWalletId: string\n  ): Promise<{ success: boolean; txHash?: string }> {\n    // In production, this would:\n    // 1. Create an AddKey transaction\n    // 2. Sign it with the MPC key\n    // 3. Submit to NEAR\n    //\n    // The recovery wallet gets a FunctionCall access key that can only:\n    // - Call our recovery contract\n    // - Not transfer funds or do anything else\n    \n    console.log('[MPC] Adding recovery wallet:', {\n      nearAccountId,\n      recoveryWalletId,\n    });\n\n    // TODO: Implement full MPC signing flow\n    // For now, mark as pending\n    void nearAccountId;\n    void recoveryWalletId;\n    \n    return {\n      success: true,\n      txHash: `pending-${Date.now()}`,\n    };\n  }\n\n  /**\n   * Verify that a wallet has recovery access to an account\n   */\n  async verifyRecoveryWallet(\n    nearAccountId: string,\n    recoveryWalletId: string\n  ): Promise<boolean> {\n    try {\n      const rpcUrl = getRPCUrl(this.networkId);\n\n      const response = await fetch(rpcUrl, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          jsonrpc: '2.0',\n          id: 'check-keys',\n          method: 'query',\n          params: {\n            request_type: 'view_access_key_list',\n            finality: 'final',\n            account_id: nearAccountId,\n          },\n        }),\n      });\n\n      const result = await response.json() as {\n        result?: { keys: Array<{ public_key: string }> };\n      };\n\n      // Check if recovery wallet's key is in the access key list\n      // This requires knowing the public key of the recovery wallet\n      // For now, return true if account exists\n      return !!result.result?.keys?.length;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get MPC contract ID\n   */\n  getMPCContractId(): string {\n    return this.mpcContractId;\n  }\n\n  /**\n   * Get network ID\n   */\n  getNetworkId(): string {\n    return this.networkId;\n  }\n}\n\n/**\n * Create MPC account manager\n */\nexport function createMPCManager(config: MPCConfig): MPCAccountManager {\n  return new MPCAccountManager(config);\n}\n","/**\n * Wallet Recovery\n * \n * Allows users to link a NEAR wallet as a recovery method.\n * The wallet is added as an on-chain access key - no mapping stored in our DB.\n */\n\nimport { createHash } from 'crypto';\nimport nacl from 'tweetnacl';\nimport bs58 from 'bs58';\n\nexport interface WalletRecoveryConfig {\n  nearNetwork: 'testnet' | 'mainnet';\n}\n\nexport interface WalletSignature {\n  signature: string;  // Base64 or hex encoded\n  publicKey: string;  // ed25519:... format\n  message: string;    // The signed message\n}\n\n/**\n * Generate a challenge message for wallet signing\n */\nexport function generateWalletChallenge(action: string, timestamp: number): string {\n  return `near-anon-auth:${action}:${timestamp}`;\n}\n\n/**\n * Verify a NEAR wallet signature\n */\nexport function verifyWalletSignature(\n  signature: WalletSignature,\n  expectedMessage: string\n): boolean {\n  try {\n    if (signature.message !== expectedMessage) {\n      return false;\n    }\n    \n    // Extract public key bytes\n    const pubKeyStr = signature.publicKey.replace('ed25519:', '');\n    const publicKeyBytes = bs58.decode(pubKeyStr);\n    \n    // Decode signature\n    const signatureBytes = Buffer.from(signature.signature, 'base64');\n    \n    // Hash the message (NEAR signs SHA256 hash)\n    const messageHash = createHash('sha256')\n      .update(signature.message)\n      .digest();\n    \n    // Verify using nacl\n    return nacl.sign.detached.verify(\n      messageHash,\n      signatureBytes,\n      publicKeyBytes\n    );\n  } catch (error) {\n    console.error('[WalletRecovery] Signature verification failed:', error);\n    return false;\n  }\n}\n\n/**\n * Extract account ID from public key (for implicit accounts)\n */\nexport function publicKeyToImplicitAccount(publicKey: string): string {\n  const pubKeyStr = publicKey.replace('ed25519:', '');\n  const publicKeyBytes = bs58.decode(pubKeyStr);\n  return Buffer.from(publicKeyBytes).toString('hex');\n}\n\n/**\n * Check if a wallet has access key on a NEAR account\n */\nexport async function checkWalletAccess(\n  nearAccountId: string,\n  walletPublicKey: string,\n  networkId: 'testnet' | 'mainnet'\n): Promise<boolean> {\n  try {\n    const rpcUrl = networkId === 'mainnet'\n      ? 'https://rpc.mainnet.near.org'\n      : 'https://rpc.testnet.near.org';\n\n    const response = await fetch(rpcUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        jsonrpc: '2.0',\n        id: 'check-access-key',\n        method: 'query',\n        params: {\n          request_type: 'view_access_key',\n          finality: 'final',\n          account_id: nearAccountId,\n          public_key: walletPublicKey,\n        },\n      }),\n    });\n\n    const result = await response.json() as { error?: unknown };\n    return !result.error;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Wallet Recovery Manager\n */\nexport interface WalletRecoveryManager {\n  /**\n   * Generate challenge for linking a wallet\n   */\n  generateLinkChallenge(): { challenge: string; expiresAt: Date };\n  \n  /**\n   * Verify wallet signature and prepare for linking\n   */\n  verifyLinkSignature(\n    signature: WalletSignature,\n    challenge: string\n  ): { verified: boolean; walletId?: string };\n  \n  /**\n   * Generate challenge for recovery\n   */\n  generateRecoveryChallenge(): { challenge: string; expiresAt: Date };\n  \n  /**\n   * Verify recovery signature\n   */\n  verifyRecoverySignature(\n    signature: WalletSignature,\n    challenge: string,\n    nearAccountId: string\n  ): Promise<{ verified: boolean }>;\n}\n\nexport function createWalletRecoveryManager(\n  config: WalletRecoveryConfig\n): WalletRecoveryManager {\n  const CHALLENGE_TIMEOUT_MS = 5 * 60 * 1000; // 5 minutes\n\n  return {\n    generateLinkChallenge() {\n      const timestamp = Date.now();\n      const challenge = generateWalletChallenge('link-recovery', timestamp);\n      const expiresAt = new Date(Date.now() + CHALLENGE_TIMEOUT_MS);\n      return { challenge, expiresAt };\n    },\n\n    verifyLinkSignature(signature, challenge) {\n      const verified = verifyWalletSignature(signature, challenge);\n      \n      if (!verified) {\n        return { verified: false };\n      }\n      \n      // Extract wallet ID from signature's public key\n      // For named accounts, we'll need the account ID from the request\n      // For implicit accounts, we derive from public key\n      const walletId = signature.publicKey;\n      \n      return { verified: true, walletId };\n    },\n\n    generateRecoveryChallenge() {\n      const timestamp = Date.now();\n      const challenge = generateWalletChallenge('recover-account', timestamp);\n      const expiresAt = new Date(Date.now() + CHALLENGE_TIMEOUT_MS);\n      return { challenge, expiresAt };\n    },\n\n    async verifyRecoverySignature(signature, challenge, nearAccountId) {\n      // First verify the signature itself\n      if (!verifyWalletSignature(signature, challenge)) {\n        return { verified: false };\n      }\n      \n      // Then verify this wallet has access to the NEAR account\n      const hasAccess = await checkWalletAccess(\n        nearAccountId,\n        signature.publicKey,\n        config.nearNetwork\n      );\n      \n      return { verified: hasAccess };\n    },\n  };\n}\n","/**\n * IPFS + Password Recovery\n * \n * Encrypts recovery data with user's password and stores on IPFS.\n * User needs password + CID to recover.\n * \n * Supported pinning services:\n * - Pinata (https://pinata.cloud)\n * - web3.storage (https://web3.storage)\n * - Infura (https://infura.io)\n */\n\nimport { randomBytes, createCipheriv, createDecipheriv, scrypt } from 'crypto';\nimport { promisify } from 'util';\n\nconst scryptAsync = promisify(scrypt);\n\nexport interface IPFSRecoveryConfig {\n  pinningService: 'pinata' | 'web3storage' | 'infura' | 'custom';\n  /** API key (required for pinata, web3storage, infura) */\n  apiKey?: string;\n  /** API secret (required for pinata, infura) */\n  apiSecret?: string;\n  /** Project ID (required for infura) */\n  projectId?: string;\n  /** Custom pinning function */\n  customPin?: (data: Uint8Array) => Promise<string>;\n  /** Custom fetch function */\n  customFetch?: (cid: string) => Promise<Uint8Array>;\n}\n\nexport interface EncryptedRecoveryData {\n  /** Encrypted payload (base64) */\n  ciphertext: string;\n  /** Initialization vector (base64) */\n  iv: string;\n  /** Salt for key derivation (base64) */\n  salt: string;\n  /** Auth tag for GCM (base64) */\n  authTag: string;\n  /** Version for future compatibility */\n  version: 1;\n}\n\nexport interface RecoveryPayload {\n  userId: string;\n  nearAccountId: string;\n  derivationPath: string;\n  createdAt: number;\n}\n\n/**\n * Derive encryption key from password\n */\nasync function deriveKey(password: string, salt: Buffer): Promise<Buffer> {\n  return scryptAsync(password, salt, 32) as Promise<Buffer>;\n}\n\n/**\n * Encrypt recovery data\n */\nexport async function encryptRecoveryData(\n  payload: RecoveryPayload,\n  password: string\n): Promise<EncryptedRecoveryData> {\n  const salt = randomBytes(32);\n  const iv = randomBytes(16);\n  const key = await deriveKey(password, salt);\n  \n  const cipher = createCipheriv('aes-256-gcm', key, iv);\n  \n  const payloadJson = JSON.stringify(payload);\n  const encrypted = Buffer.concat([\n    cipher.update(payloadJson, 'utf8'),\n    cipher.final(),\n  ]);\n  \n  const authTag = cipher.getAuthTag();\n  \n  return {\n    ciphertext: encrypted.toString('base64'),\n    iv: iv.toString('base64'),\n    salt: salt.toString('base64'),\n    authTag: authTag.toString('base64'),\n    version: 1,\n  };\n}\n\n/**\n * Decrypt recovery data\n */\nexport async function decryptRecoveryData(\n  encryptedData: EncryptedRecoveryData,\n  password: string\n): Promise<RecoveryPayload> {\n  const salt = Buffer.from(encryptedData.salt, 'base64');\n  const iv = Buffer.from(encryptedData.iv, 'base64');\n  const ciphertext = Buffer.from(encryptedData.ciphertext, 'base64');\n  const authTag = Buffer.from(encryptedData.authTag, 'base64');\n  \n  const key = await deriveKey(password, salt);\n  \n  const decipher = createDecipheriv('aes-256-gcm', key, iv);\n  decipher.setAuthTag(authTag);\n  \n  try {\n    const decrypted = Buffer.concat([\n      decipher.update(ciphertext),\n      decipher.final(),\n    ]);\n    \n    return JSON.parse(decrypted.toString('utf8'));\n  } catch {\n    throw new Error('Invalid password or corrupted data');\n  }\n}\n\n// ============================================\n// Pinning Services\n// ============================================\n\n/**\n * Pin data to IPFS using Pinata\n * https://docs.pinata.cloud/api-reference/endpoint/pin-file-to-ipfs\n */\nasync function pinToPinata(\n  data: Uint8Array,\n  apiKey: string,\n  apiSecret: string\n): Promise<string> {\n  const formData = new FormData();\n  const buffer = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength) as ArrayBuffer;\n  formData.append('file', new Blob([buffer]), 'recovery.json');\n  \n  const response = await fetch('https://api.pinata.cloud/pinning/pinFileToIPFS', {\n    method: 'POST',\n    headers: {\n      'pinata_api_key': apiKey,\n      'pinata_secret_api_key': apiSecret,\n    },\n    body: formData,\n  });\n  \n  if (!response.ok) {\n    const error = await response.text();\n    throw new Error(`Pinata error: ${response.status} - ${error}`);\n  }\n  \n  const result = await response.json() as { IpfsHash: string };\n  return result.IpfsHash;\n}\n\n/**\n * Pin data to IPFS using web3.storage\n * https://web3.storage/docs/how-to/upload/\n */\nasync function pinToWeb3Storage(\n  data: Uint8Array,\n  apiToken: string\n): Promise<string> {\n  const buffer = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength) as ArrayBuffer;\n  \n  const response = await fetch('https://api.web3.storage/upload', {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${apiToken}`,\n      'Content-Type': 'application/octet-stream',\n      'X-Name': 'phantom-recovery.json',\n    },\n    body: buffer,\n  });\n  \n  if (!response.ok) {\n    const error = await response.text();\n    throw new Error(`web3.storage error: ${response.status} - ${error}`);\n  }\n  \n  const result = await response.json() as { cid: string };\n  return result.cid;\n}\n\n/**\n * Pin data to IPFS using Infura\n * https://docs.infura.io/infura/networks/ipfs/http-api-methods/add\n */\nasync function pinToInfura(\n  data: Uint8Array,\n  projectId: string,\n  projectSecret: string\n): Promise<string> {\n  const formData = new FormData();\n  const buffer = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength) as ArrayBuffer;\n  formData.append('file', new Blob([buffer]), 'recovery.json');\n  \n  const auth = Buffer.from(`${projectId}:${projectSecret}`).toString('base64');\n  \n  const response = await fetch('https://ipfs.infura.io:5001/api/v0/add', {\n    method: 'POST',\n    headers: {\n      'Authorization': `Basic ${auth}`,\n    },\n    body: formData,\n  });\n  \n  if (!response.ok) {\n    const error = await response.text();\n    throw new Error(`Infura error: ${response.status} - ${error}`);\n  }\n  \n  const result = await response.json() as { Hash: string };\n  return result.Hash;\n}\n\n/**\n * Fetch data from IPFS gateway\n */\nasync function fetchFromIPFS(cid: string): Promise<Uint8Array> {\n  // Try multiple gateways for reliability\n  const gateways = [\n    `https://gateway.pinata.cloud/ipfs/${cid}`,\n    `https://w3s.link/ipfs/${cid}`,\n    `https://ipfs.infura.io/ipfs/${cid}`,\n    `https://ipfs.io/ipfs/${cid}`,\n    `https://cloudflare-ipfs.com/ipfs/${cid}`,\n    `https://dweb.link/ipfs/${cid}`,\n  ];\n  \n  for (const gateway of gateways) {\n    try {\n      const response = await fetch(gateway, {\n        headers: {\n          'Accept': 'application/octet-stream',\n        },\n      });\n      if (response.ok) {\n        return new Uint8Array(await response.arrayBuffer());\n      }\n    } catch {\n      continue;\n    }\n  }\n  \n  throw new Error('Failed to fetch from IPFS - tried all gateways');\n}\n\n/**\n * IPFS Recovery Manager\n */\nexport interface IPFSRecoveryManager {\n  /**\n   * Create and pin encrypted recovery data\n   */\n  createRecoveryBackup(\n    payload: RecoveryPayload,\n    password: string\n  ): Promise<{ cid: string }>;\n  \n  /**\n   * Recover data from IPFS\n   */\n  recoverFromBackup(\n    cid: string,\n    password: string\n  ): Promise<RecoveryPayload>;\n  \n  /**\n   * Validate password strength\n   */\n  validatePassword(password: string): {\n    valid: boolean;\n    errors: string[];\n    strength: 'weak' | 'medium' | 'strong';\n  };\n}\n\nexport function createIPFSRecoveryManager(\n  config: IPFSRecoveryConfig\n): IPFSRecoveryManager {\n  const MIN_PASSWORD_LENGTH = 12;\n\n  async function pinData(data: Uint8Array): Promise<string> {\n    if (config.customPin) {\n      return config.customPin(data);\n    }\n    \n    switch (config.pinningService) {\n      case 'pinata':\n        if (!config.apiKey || !config.apiSecret) {\n          throw new Error('Pinata requires apiKey and apiSecret');\n        }\n        return pinToPinata(data, config.apiKey, config.apiSecret);\n      \n      case 'web3storage':\n        if (!config.apiKey) {\n          throw new Error('web3.storage requires apiKey (API token)');\n        }\n        return pinToWeb3Storage(data, config.apiKey);\n      \n      case 'infura':\n        if (!config.projectId || !config.apiSecret) {\n          throw new Error('Infura requires projectId and apiSecret');\n        }\n        return pinToInfura(data, config.projectId, config.apiSecret);\n      \n      case 'custom':\n        throw new Error('Custom pinning requires customPin function');\n      \n      default:\n        throw new Error(`Unknown pinning service: ${config.pinningService}`);\n    }\n  }\n\n  async function fetchData(cid: string): Promise<Uint8Array> {\n    if (config.customFetch) {\n      return config.customFetch(cid);\n    }\n    return fetchFromIPFS(cid);\n  }\n\n  function calculatePasswordStrength(password: string): 'weak' | 'medium' | 'strong' {\n    let score = 0;\n    \n    if (password.length >= 12) score++;\n    if (password.length >= 16) score++;\n    if (/[a-z]/.test(password)) score++;\n    if (/[A-Z]/.test(password)) score++;\n    if (/[0-9]/.test(password)) score++;\n    if (/[^a-zA-Z0-9]/.test(password)) score++;\n    \n    if (score <= 2) return 'weak';\n    if (score <= 4) return 'medium';\n    return 'strong';\n  }\n\n  return {\n    async createRecoveryBackup(payload, password) {\n      // Validate password\n      const validation = this.validatePassword(password);\n      if (!validation.valid) {\n        throw new Error(`Invalid password: ${validation.errors.join(', ')}`);\n      }\n      \n      // Encrypt payload\n      const encrypted = await encryptRecoveryData(payload, password);\n      \n      // Convert to bytes\n      const data = new TextEncoder().encode(JSON.stringify(encrypted));\n      \n      // Pin to IPFS\n      const cid = await pinData(data);\n      \n      console.log(`[IPFS] Recovery backup created: ${cid} (${config.pinningService})`);\n      \n      return { cid };\n    },\n\n    async recoverFromBackup(cid, password) {\n      // Fetch from IPFS\n      const data = await fetchData(cid);\n      \n      // Parse encrypted data\n      const encrypted: EncryptedRecoveryData = JSON.parse(\n        new TextDecoder().decode(data)\n      );\n      \n      // Decrypt\n      return decryptRecoveryData(encrypted, password);\n    },\n\n    validatePassword(password) {\n      const errors: string[] = [];\n      \n      if (password.length < MIN_PASSWORD_LENGTH) {\n        errors.push(`Password must be at least ${MIN_PASSWORD_LENGTH} characters`);\n      }\n      \n      if (!/[a-z]/.test(password)) {\n        errors.push('Password must contain lowercase letters');\n      }\n      \n      if (!/[A-Z]/.test(password)) {\n        errors.push('Password must contain uppercase letters');\n      }\n      \n      if (!/[0-9]/.test(password)) {\n        errors.push('Password must contain numbers');\n      }\n      \n      const strength = calculatePasswordStrength(password);\n      \n      return {\n        valid: errors.length === 0,\n        errors,\n        strength,\n      };\n    },\n  };\n}\n","/**\n * OAuth Provider Manager\n * \n * Manages OAuth authentication alongside passkey auth.\n * Supports Google, GitHub, and X (Twitter) OAuth providers.\n */\n\nimport type { DatabaseAdapter, OAuthUser, CreateOAuthUserInput } from '../../types/index.js';\nimport { createHash, randomBytes } from 'crypto';\n\nexport interface OAuthProviderConfig {\n  google?: {\n    clientId: string;\n    clientSecret: string;\n  };\n  github?: {\n    clientId: string;\n    clientSecret: string;\n  };\n  twitter?: {\n    clientId: string;\n    clientSecret: string;\n  };\n}\n\nexport interface OAuthState {\n  provider: 'google' | 'github' | 'twitter';\n  state: string;\n  codeVerifier?: string;\n  redirectUri: string;\n  expiresAt: Date;\n}\n\nexport interface OAuthTokens {\n  accessToken: string;\n  refreshToken?: string;\n  expiresIn: number;\n  tokenType: string;\n}\n\nexport interface OAuthProfile {\n  provider: 'google' | 'github' | 'twitter';\n  providerId: string;\n  email?: string;\n  name?: string;\n  avatarUrl?: string;\n  raw: Record<string, unknown>;\n}\n\nexport interface OAuthManager {\n  getAuthUrl(provider: 'google' | 'github' | 'twitter', redirectUri: string): Promise<{\n    url: string;\n    state: string;\n    codeVerifier?: string;\n  }>;\n  \n  exchangeCode(\n    provider: 'google' | 'github' | 'twitter',\n    code: string,\n    redirectUri: string,\n    codeVerifier?: string\n  ): Promise<OAuthTokens>;\n  \n  getProfile(provider: 'google' | 'github' | 'twitter', accessToken: string): Promise<OAuthProfile>;\n  \n  validateState(state: string): Promise<OAuthState | null>;\n  \n  isConfigured(provider: 'google' | 'github' | 'twitter'): boolean;\n}\n\n/**\n * Generate PKCE code verifier and challenge\n */\nfunction generatePKCE(): { codeVerifier: string; codeChallenge: string } {\n  const codeVerifier = randomBytes(32).toString('base64url');\n  const codeChallenge = createHash('sha256')\n    .update(codeVerifier)\n    .digest('base64url');\n  return { codeVerifier, codeChallenge };\n}\n\n/**\n * Generate state parameter for OAuth\n */\nfunction generateState(): string {\n  return randomBytes(32).toString('base64url');\n}\n\n/**\n * Create OAuth Manager\n */\nexport function createOAuthManager(\n  config: OAuthProviderConfig,\n  db: DatabaseAdapter\n): OAuthManager {\n  const stateStore = new Map<string, OAuthState>();\n\n  return {\n    isConfigured(provider) {\n      return !!config[provider]?.clientId;\n    },\n\n    async getAuthUrl(provider, redirectUri) {\n      const providerConfig = config[provider];\n      if (!providerConfig) {\n        throw new Error(`Provider ${provider} not configured`);\n      }\n\n      const state = generateState();\n      const { codeVerifier, codeChallenge } = generatePKCE();\n\n      let url: string;\n      const { clientId } = providerConfig;\n\n      switch (provider) {\n        case 'google': {\n          const params = new URLSearchParams({\n            client_id: clientId,\n            redirect_uri: redirectUri,\n            response_type: 'code',\n            scope: 'openid email profile',\n            state,\n            code_challenge: codeChallenge,\n            code_challenge_method: 'S256',\n            access_type: 'offline',\n            prompt: 'consent',\n          });\n          url = `https://accounts.google.com/o/oauth2/v2/auth?${params}`;\n          break;\n        }\n\n        case 'github': {\n          const params = new URLSearchParams({\n            client_id: clientId,\n            redirect_uri: redirectUri,\n            scope: 'read:user user:email',\n            state,\n          });\n          url = `https://github.com/login/oauth/authorize?${params}`;\n          break;\n        }\n\n        case 'twitter': {\n          const params = new URLSearchParams({\n            client_id: clientId,\n            redirect_uri: redirectUri,\n            response_type: 'code',\n            scope: 'tweet.read users.read offline.access',\n            state,\n            code_challenge: codeChallenge,\n            code_challenge_method: 'S256',\n          });\n          url = `https://twitter.com/i/oauth2/authorize?${params}`;\n          break;\n        }\n\n        default:\n          throw new Error(`Unknown provider: ${provider}`);\n      }\n\n      // Store state for validation\n      const oauthState: OAuthState = {\n        provider,\n        state,\n        codeVerifier,\n        redirectUri,\n        expiresAt: new Date(Date.now() + 10 * 60 * 1000), // 10 minutes\n      };\n      stateStore.set(state, oauthState);\n\n      // Clean up old states\n      for (const [key, value] of stateStore.entries()) {\n        if (value.expiresAt < new Date()) {\n          stateStore.delete(key);\n        }\n      }\n\n      return { url, state, codeVerifier };\n    },\n\n    async exchangeCode(provider, code, redirectUri, codeVerifier) {\n      const providerConfig = config[provider];\n      if (!providerConfig) {\n        throw new Error(`Provider ${provider} not configured`);\n      }\n\n      const { clientId, clientSecret } = providerConfig;\n      let tokenUrl: string;\n      let body: URLSearchParams;\n\n      switch (provider) {\n        case 'google': {\n          tokenUrl = 'https://oauth2.googleapis.com/token';\n          body = new URLSearchParams({\n            client_id: clientId,\n            client_secret: clientSecret,\n            code,\n            redirect_uri: redirectUri,\n            grant_type: 'authorization_code',\n            code_verifier: codeVerifier || '',\n          });\n          break;\n        }\n\n        case 'github': {\n          tokenUrl = 'https://github.com/login/oauth/access_token';\n          body = new URLSearchParams({\n            client_id: clientId,\n            client_secret: clientSecret,\n            code,\n            redirect_uri: redirectUri,\n          });\n          break;\n        }\n\n        case 'twitter': {\n          tokenUrl = 'https://api.twitter.com/2/oauth2/token';\n          body = new URLSearchParams({\n            client_id: clientId,\n            code,\n            redirect_uri: redirectUri,\n            grant_type: 'authorization_code',\n            code_verifier: codeVerifier || '',\n          });\n          break;\n        }\n\n        default:\n          throw new Error(`Unknown provider: ${provider}`);\n      }\n\n      const headers: Record<string, string> = {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        Accept: 'application/json',\n      };\n\n      // Twitter requires Basic auth\n      if (provider === 'twitter') {\n        const credentials = Buffer.from(`${clientId}:${clientSecret}`).toString('base64');\n        headers['Authorization'] = `Basic ${credentials}`;\n      }\n\n      const response = await fetch(tokenUrl, {\n        method: 'POST',\n        headers,\n        body,\n      });\n\n      if (!response.ok) {\n        const error = await response.text();\n        throw new Error(`Token exchange failed: ${error}`);\n      }\n\n      const data = await response.json() as {\n        access_token: string;\n        refresh_token?: string;\n        expires_in?: number;\n        token_type?: string;\n      };\n\n      return {\n        accessToken: data.access_token,\n        refreshToken: data.refresh_token,\n        expiresIn: data.expires_in || 3600,\n        tokenType: data.token_type || 'Bearer',\n      };\n    },\n\n    async getProfile(provider, accessToken) {\n      let profileUrl: string;\n      const headers: Record<string, string> = {\n        Authorization: `Bearer ${accessToken}`,\n        Accept: 'application/json',\n      };\n\n      switch (provider) {\n        case 'google':\n          profileUrl = 'https://www.googleapis.com/oauth2/v2/userinfo';\n          break;\n\n        case 'github':\n          profileUrl = 'https://api.github.com/user';\n          break;\n\n        case 'twitter':\n          profileUrl = 'https://api.twitter.com/2/users/me?user.fields=profile_image_url';\n          break;\n\n        default:\n          throw new Error(`Unknown provider: ${provider}`);\n      }\n\n      const response = await fetch(profileUrl, { headers });\n\n      if (!response.ok) {\n        const error = await response.text();\n        throw new Error(`Profile fetch failed: ${error}`);\n      }\n\n      const data = await response.json() as Record<string, unknown>;\n\n      // Normalize profile data\n      switch (provider) {\n        case 'google':\n          return {\n            provider,\n            providerId: String(data.id),\n            email: data.email as string | undefined,\n            name: data.name as string | undefined,\n            avatarUrl: data.picture as string | undefined,\n            raw: data,\n          };\n\n        case 'github': {\n          // GitHub requires separate call for email if private\n          let email = data.email as string | undefined;\n          if (!email) {\n            try {\n              const emailResponse = await fetch('https://api.github.com/user/emails', { headers });\n              if (emailResponse.ok) {\n                const emails = await emailResponse.json() as Array<{\n                  email: string;\n                  primary: boolean;\n                  verified: boolean;\n                }>;\n                const primary = emails.find(e => e.primary && e.verified);\n                email = primary?.email;\n              }\n            } catch {\n              // Email fetch failed, continue without\n            }\n          }\n          return {\n            provider,\n            providerId: String(data.id),\n            email,\n            name: (data.name || data.login) as string | undefined,\n            avatarUrl: data.avatar_url as string | undefined,\n            raw: data,\n          };\n        }\n\n        case 'twitter': {\n          const twitterData = data.data as Record<string, unknown>;\n          return {\n            provider,\n            providerId: String(twitterData.id),\n            email: undefined, // Twitter doesn't provide email\n            name: twitterData.name as string | undefined,\n            avatarUrl: twitterData.profile_image_url as string | undefined,\n            raw: data,\n          };\n        }\n\n        default:\n          throw new Error(`Unknown provider: ${provider}`);\n      }\n    },\n\n    async validateState(state) {\n      const oauthState = stateStore.get(state);\n      if (!oauthState) {\n        return null;\n      }\n      if (oauthState.expiresAt < new Date()) {\n        stateStore.delete(state);\n        return null;\n      }\n      stateStore.delete(state);\n      return oauthState;\n    },\n  };\n}\n\n// Types already exported at interface declaration\n","/**\n * OAuth Router\n * \n * API routes for OAuth authentication.\n */\n\nimport { Router, json } from 'express';\nimport type { Request, Response } from 'express';\nimport type { SessionManager } from '../session.js';\nimport type { MPCAccountManager } from '../mpc.js';\nimport type { IPFSRecoveryManager } from '../recovery/ipfs.js';\nimport type { DatabaseAdapter, OAuthConfig, OAuthProvider } from '../../types/index.js';\nimport { createOAuthManager, type OAuthManager, type OAuthProfile } from './index.js';\n\nexport interface OAuthRouterConfig {\n  db: DatabaseAdapter;\n  sessionManager: SessionManager;\n  mpcManager: MPCAccountManager;\n  oauthConfig: OAuthConfig;\n  ipfsRecovery?: IPFSRecoveryManager;\n}\n\nexport function createOAuthRouter(config: OAuthRouterConfig): Router {\n  const router = Router();\n  const {\n    db,\n    sessionManager,\n    mpcManager,\n    oauthConfig,\n    ipfsRecovery,\n  } = config;\n\n  // Create OAuth manager\n  const oauthManager = createOAuthManager(\n    {\n      google: oauthConfig.google,\n      github: oauthConfig.github,\n      twitter: oauthConfig.twitter,\n    },\n    db\n  );\n\n  router.use(json());\n\n  // ============================================\n  // OAuth Provider Info\n  // ============================================\n\n  /**\n   * GET /oauth/providers\n   * Get available OAuth providers\n   */\n  router.get('/providers', (_req: Request, res: Response) => {\n    res.json({\n      providers: {\n        google: oauthManager.isConfigured('google'),\n        github: oauthManager.isConfigured('github'),\n        twitter: oauthManager.isConfigured('twitter'),\n      },\n    });\n  });\n\n  // ============================================\n  // OAuth Flow Start\n  // ============================================\n\n  /**\n   * GET /oauth/:provider/start\n   * Start OAuth flow for a provider\n   */\n  router.get('/:provider/start', async (req: Request, res: Response) => {\n    try {\n      const provider = req.params.provider as 'google' | 'github' | 'twitter';\n      \n      if (!['google', 'github', 'twitter'].includes(provider)) {\n        return res.status(400).json({ error: 'Invalid provider' });\n      }\n\n      if (!oauthManager.isConfigured(provider)) {\n        return res.status(400).json({ error: `${provider} OAuth not configured` });\n      }\n\n      const redirectUri = `${oauthConfig.callbackBaseUrl}/${provider}`;\n      const { url, state, codeVerifier } = await oauthManager.getAuthUrl(provider, redirectUri);\n\n      // Store code verifier in session/cookie for PKCE\n      if (codeVerifier) {\n        res.cookie('oauth_code_verifier', codeVerifier, {\n          httpOnly: true,\n          secure: process.env.NODE_ENV === 'production',\n          sameSite: 'lax',\n          maxAge: 10 * 60 * 1000, // 10 minutes\n        });\n      }\n\n      res.cookie('oauth_state', state, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === 'production',\n        sameSite: 'lax',\n        maxAge: 10 * 60 * 1000,\n      });\n\n      return res.json({ url, state });\n    } catch (error) {\n      console.error('[OAuth] Start error:', error);\n      return res.status(500).json({ error: 'Failed to start OAuth flow' });\n    }\n  });\n\n  // ============================================\n  // OAuth Callback\n  // ============================================\n\n  /**\n   * POST /oauth/:provider/callback\n   * Handle OAuth callback\n   */\n  router.post('/:provider/callback', async (req: Request, res: Response) => {\n    try {\n      const provider = req.params.provider as 'google' | 'github' | 'twitter';\n      const { code, state } = req.body;\n\n      if (!code || !state) {\n        return res.status(400).json({ error: 'Missing code or state' });\n      }\n\n      // Validate state\n      const storedState = req.cookies?.oauth_state;\n      if (state !== storedState) {\n        return res.status(400).json({ error: 'Invalid state' });\n      }\n\n      // Get code verifier for PKCE\n      const codeVerifier = req.cookies?.oauth_code_verifier;\n\n      // Clear OAuth cookies\n      res.clearCookie('oauth_state');\n      res.clearCookie('oauth_code_verifier');\n\n      // Exchange code for tokens\n      const redirectUri = `${oauthConfig.callbackBaseUrl}/${provider}`;\n      const tokens = await oauthManager.exchangeCode(provider, code, redirectUri, codeVerifier);\n\n      // Get user profile\n      const profile = await oauthManager.getProfile(provider, tokens.accessToken);\n\n      // Check if user exists with this provider\n      let user = await db.getOAuthUserByProvider(provider, profile.providerId);\n\n      if (user) {\n        // Existing user - update last active and create session\n        await sessionManager.createSession(user.id, res, {\n          ipAddress: req.ip,\n          userAgent: req.headers['user-agent'],\n        });\n\n        return res.json({\n          success: true,\n          user: {\n            id: user.id,\n            email: user.email,\n            name: user.name,\n            avatarUrl: user.avatarUrl,\n            nearAccountId: user.nearAccountId,\n            type: 'standard',\n          },\n          isNewUser: false,\n        });\n      }\n\n      // Check if user exists with this email (link accounts)\n      if (profile.email) {\n        user = await db.getOAuthUserByEmail(profile.email);\n        if (user) {\n          // Link this provider to existing account\n          const providerData: OAuthProvider = {\n            provider,\n            providerId: profile.providerId,\n            email: profile.email,\n            name: profile.name,\n            avatarUrl: profile.avatarUrl,\n            connectedAt: new Date(),\n          };\n          await db.linkOAuthProvider(user.id, providerData);\n\n          await sessionManager.createSession(user.id, res, {\n            ipAddress: req.ip,\n            userAgent: req.headers['user-agent'],\n          });\n\n          return res.json({\n            success: true,\n            user: {\n              id: user.id,\n              email: user.email,\n              name: user.name,\n              avatarUrl: user.avatarUrl,\n              nearAccountId: user.nearAccountId,\n              type: 'standard',\n            },\n            isNewUser: false,\n            linkedProvider: provider,\n          });\n        }\n      }\n\n      // New user - create account with MPC\n      const tempUserId = crypto.randomUUID();\n      const mpcAccount = await mpcManager.createAccount(tempUserId);\n\n      const providerData: OAuthProvider = {\n        provider,\n        providerId: profile.providerId,\n        email: profile.email,\n        name: profile.name,\n        avatarUrl: profile.avatarUrl,\n        connectedAt: new Date(),\n      };\n\n      const newUser = await db.createOAuthUser({\n        email: profile.email || `${profile.providerId}@${provider}.oauth`,\n        name: profile.name,\n        avatarUrl: profile.avatarUrl,\n        nearAccountId: mpcAccount.nearAccountId,\n        mpcPublicKey: mpcAccount.mpcPublicKey,\n        derivationPath: mpcAccount.derivationPath,\n        provider: providerData,\n      });\n\n      // Create IPFS recovery backup automatically for OAuth users\n      if (ipfsRecovery && profile.email) {\n        try {\n          const recoveryPassword = crypto.randomUUID(); // Auto-generated, sent to email\n          const { cid } = await ipfsRecovery.createRecoveryBackup(\n            {\n              userId: newUser.id,\n              nearAccountId: newUser.nearAccountId,\n              derivationPath: newUser.derivationPath,\n              createdAt: Date.now(),\n            },\n            recoveryPassword\n          );\n\n          await db.storeRecoveryData({\n            userId: newUser.id,\n            type: 'ipfs',\n            reference: cid,\n            createdAt: new Date(),\n          });\n\n          // TODO: Send recovery info to user's email\n          console.log('[OAuth] Recovery backup created for new user:', cid);\n        } catch (error) {\n          console.error('[OAuth] Failed to create recovery backup:', error);\n        }\n      }\n\n      // Create session\n      await sessionManager.createSession(newUser.id, res, {\n        ipAddress: req.ip,\n        userAgent: req.headers['user-agent'],\n      });\n\n      return res.json({\n        success: true,\n        user: {\n          id: newUser.id,\n          email: newUser.email,\n          name: newUser.name,\n          avatarUrl: newUser.avatarUrl,\n          nearAccountId: newUser.nearAccountId,\n          type: 'standard',\n        },\n        isNewUser: true,\n      });\n    } catch (error) {\n      console.error('[OAuth] Callback error:', error);\n      return res.status(500).json({ error: 'OAuth authentication failed' });\n    }\n  });\n\n  // ============================================\n  // Link Additional Provider\n  // ============================================\n\n  /**\n   * POST /oauth/:provider/link\n   * Link additional OAuth provider to existing account\n   */\n  router.post('/:provider/link', async (req: Request, res: Response) => {\n    try {\n      const session = await sessionManager.getSession(req);\n      if (!session) {\n        return res.status(401).json({ error: 'Authentication required' });\n      }\n\n      const provider = req.params.provider as 'google' | 'github' | 'twitter';\n      const { code, state, codeVerifier } = req.body;\n\n      if (!code) {\n        return res.status(400).json({ error: 'Missing code' });\n      }\n\n      // Exchange code for tokens\n      const redirectUri = `${oauthConfig.callbackBaseUrl}/${provider}`;\n      const tokens = await oauthManager.exchangeCode(provider, code, redirectUri, codeVerifier);\n\n      // Get user profile\n      const profile = await oauthManager.getProfile(provider, tokens.accessToken);\n\n      // Check if this provider is already linked to another account\n      const existingUser = await db.getOAuthUserByProvider(provider, profile.providerId);\n      if (existingUser && existingUser.id !== session.userId) {\n        return res.status(400).json({ error: 'This account is already linked to another user' });\n      }\n\n      // Link provider to current user\n      const providerData: OAuthProvider = {\n        provider,\n        providerId: profile.providerId,\n        email: profile.email,\n        name: profile.name,\n        avatarUrl: profile.avatarUrl,\n        connectedAt: new Date(),\n      };\n\n      await db.linkOAuthProvider(session.userId, providerData);\n\n      return res.json({\n        success: true,\n        message: `${provider} account linked successfully`,\n      });\n    } catch (error) {\n      console.error('[OAuth] Link error:', error);\n      return res.status(500).json({ error: 'Failed to link provider' });\n    }\n  });\n\n  return router;\n}\n","/**\n * Express Middleware\n * \n * Authentication middleware and route protection for Express apps.\n */\n\nimport type { Request, Response, NextFunction, RequestHandler } from 'express';\nimport type { SessionManager } from './session.js';\nimport type { DatabaseAdapter, AnonUser } from '../types/index.js';\n\n/**\n * Create authentication middleware\n * \n * Attaches user and session to request if valid session exists.\n */\nexport function createAuthMiddleware(\n  sessionManager: SessionManager,\n  db: DatabaseAdapter\n): RequestHandler {\n  return async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const session = await sessionManager.getSession(req);\n      \n      if (session) {\n        const user = await db.getUserById(session.userId);\n        \n        if (user) {\n          req.anonUser = user;\n          req.anonSession = session;\n          \n          // Refresh session (sliding window)\n          await sessionManager.refreshSession(req, res);\n        }\n      }\n      \n      next();\n    } catch (error) {\n      console.error('[AnonAuth] Middleware error:', error);\n      next();\n    }\n  };\n}\n\n/**\n * Create route protection middleware\n * \n * Returns 401 if no valid session.\n */\nexport function createRequireAuth(\n  sessionManager: SessionManager,\n  db: DatabaseAdapter\n): RequestHandler {\n  return async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const session = await sessionManager.getSession(req);\n      \n      if (!session) {\n        return res.status(401).json({ error: 'Authentication required' });\n      }\n      \n      const user = await db.getUserById(session.userId);\n      \n      if (!user) {\n        return res.status(401).json({ error: 'User not found' });\n      }\n      \n      req.anonUser = user;\n      req.anonSession = session;\n      \n      // Refresh session\n      await sessionManager.refreshSession(req, res);\n      \n      next();\n    } catch (error) {\n      console.error('[AnonAuth] Auth check error:', error);\n      res.status(500).json({ error: 'Authentication check failed' });\n    }\n  };\n}\n","/**\n * Codename Generator\n * \n * Generates anonymous codenames for HUMINT sources\n */\n\nimport { randomBytes } from 'crypto';\n\nconst NATO_PHONETIC = [\n  'ALPHA', 'BRAVO', 'CHARLIE', 'DELTA', 'ECHO', 'FOXTROT', 'GOLF', 'HOTEL',\n  'INDIA', 'JULIET', 'KILO', 'LIMA', 'MIKE', 'NOVEMBER', 'OSCAR', 'PAPA',\n  'QUEBEC', 'ROMEO', 'SIERRA', 'TANGO', 'UNIFORM', 'VICTOR', 'WHISKEY',\n  'XRAY', 'YANKEE', 'ZULU'\n];\n\nconst ADJECTIVES = [\n  'SWIFT', 'SILENT', 'SHADOW', 'STEEL', 'STORM', 'FROST', 'CRIMSON', 'GOLDEN',\n  'SILVER', 'IRON', 'DARK', 'BRIGHT', 'RAPID', 'GHOST', 'PHANTOM', 'ARCTIC',\n  'DESERT', 'OCEAN', 'MOUNTAIN', 'FOREST', 'THUNDER', 'LIGHTNING', 'COSMIC'\n];\n\nconst ANIMALS = [\n  'FALCON', 'EAGLE', 'HAWK', 'WOLF', 'BEAR', 'LION', 'TIGER', 'PANTHER',\n  'COBRA', 'VIPER', 'RAVEN', 'OWL', 'SHARK', 'DRAGON', 'PHOENIX', 'GRIFFIN',\n  'LEOPARD', 'JAGUAR', 'LYNX', 'FOX', 'ORCA', 'RAPTOR', 'CONDOR'\n];\n\nexport type CodenameStyle = 'nato-phonetic' | 'animals' | 'custom';\n\n/**\n * Generate a random number suffix (1-99)\n */\nfunction randomSuffix(): number {\n  const bytes = randomBytes(1);\n  return (bytes[0] % 99) + 1;\n}\n\n/**\n * Pick a random element from an array\n */\nfunction randomPick<T>(array: T[]): T {\n  const bytes = randomBytes(1);\n  return array[bytes[0] % array.length];\n}\n\n/**\n * Generate NATO phonetic codename (e.g., ALPHA-7, BRAVO-42)\n */\nexport function generateNatoCodename(): string {\n  const word = randomPick(NATO_PHONETIC);\n  const num = randomSuffix();\n  return `${word}-${num}`;\n}\n\n/**\n * Generate animal codename (e.g., SWIFT-FALCON-42)\n */\nexport function generateAnimalCodename(): string {\n  const adj = randomPick(ADJECTIVES);\n  const animal = randomPick(ANIMALS);\n  const num = randomSuffix();\n  return `${adj}-${animal}-${num}`;\n}\n\n/**\n * Generate codename based on style\n */\nexport function generateCodename(style: CodenameStyle = 'nato-phonetic'): string {\n  switch (style) {\n    case 'nato-phonetic':\n      return generateNatoCodename();\n    case 'animals':\n      return generateAnimalCodename();\n    default:\n      return generateNatoCodename();\n  }\n}\n\n/**\n * Check if a codename format is valid\n */\nexport function isValidCodename(codename: string): boolean {\n  // NATO: WORD-NN\n  const natoPattern = /^[A-Z]+-\\d{1,2}$/;\n  // Animal: WORD-WORD-NN\n  const animalPattern = /^[A-Z]+-[A-Z]+-\\d{1,2}$/;\n  \n  return natoPattern.test(codename) || animalPattern.test(codename);\n}\n","/**\n * Express Router\n * \n * API routes for registration, authentication, and recovery.\n */\n\nimport { Router, json } from 'express';\nimport type { Request, Response } from 'express';\nimport type { SessionManager } from './session.js';\nimport type { PasskeyManager } from './passkey.js';\nimport type { MPCAccountManager } from './mpc.js';\nimport type { WalletRecoveryManager } from './recovery/wallet.js';\nimport type { IPFSRecoveryManager } from './recovery/ipfs.js';\nimport type { DatabaseAdapter, CodenameConfig } from '../types/index.js';\nimport { generateCodename, isValidCodename } from './codename.js';\n\nexport interface RouterConfig {\n  db: DatabaseAdapter;\n  sessionManager: SessionManager;\n  passkeyManager: PasskeyManager;\n  mpcManager: MPCAccountManager;\n  walletRecovery?: WalletRecoveryManager;\n  ipfsRecovery?: IPFSRecoveryManager;\n  codename?: CodenameConfig;\n}\n\nexport function createRouter(config: RouterConfig): Router {\n  const router = Router();\n  const {\n    db,\n    sessionManager,\n    passkeyManager,\n    mpcManager,\n    walletRecovery,\n    ipfsRecovery,\n  } = config;\n\n  // Parse JSON bodies\n  router.use(json());\n\n  // ============================================\n  // Registration\n  // ============================================\n\n  /**\n   * POST /register/start\n   * Start passkey registration\n   */\n  router.post('/register/start', async (req: Request, res: Response) => {\n    try {\n      // Generate temporary user ID for registration\n      const tempUserId = crypto.randomUUID();\n      \n      // Generate codename\n      const style = config.codename?.style || 'nato-phonetic';\n      let codename: string;\n      \n      if (config.codename?.generator) {\n        codename = config.codename.generator(tempUserId);\n      } else {\n        codename = generateCodename(style);\n      }\n      \n      // Ensure codename is unique\n      let attempts = 0;\n      while (await db.getUserByCodename(codename) && attempts < 10) {\n        codename = generateCodename(style);\n        attempts++;\n      }\n      \n      if (attempts >= 10) {\n        return res.status(500).json({ error: 'Failed to generate unique codename' });\n      }\n      \n      const { challengeId, options } = await passkeyManager.startRegistration(\n        tempUserId,\n        codename\n      );\n      \n      res.json({\n        challengeId,\n        options,\n        codename,\n        tempUserId,\n      });\n    } catch (error) {\n      console.error('[AnonAuth] Registration start error:', error);\n      res.status(500).json({ error: 'Registration failed' });\n    }\n  });\n\n  /**\n   * POST /register/finish\n   * Complete passkey registration\n   */\n  router.post('/register/finish', async (req: Request, res: Response) => {\n    try {\n      const { challengeId, response, tempUserId, codename } = req.body;\n      \n      if (!challengeId || !response || !tempUserId || !codename) {\n        return res.status(400).json({ error: 'Missing required fields' });\n      }\n      \n      if (!isValidCodename(codename)) {\n        return res.status(400).json({ error: 'Invalid codename format' });\n      }\n      \n      // Verify passkey registration\n      const { verified, passkey } = await passkeyManager.finishRegistration(\n        challengeId,\n        response\n      );\n      \n      if (!verified || !passkey) {\n        return res.status(400).json({ error: 'Passkey verification failed' });\n      }\n      \n      // Create NEAR account via MPC\n      const mpcAccount = await mpcManager.createAccount(tempUserId);\n      \n      // Create user\n      const user = await db.createUser({\n        codename,\n        nearAccountId: mpcAccount.nearAccountId,\n        mpcPublicKey: mpcAccount.mpcPublicKey,\n        derivationPath: mpcAccount.derivationPath,\n      });\n      \n      // Update passkey with real user ID\n      // (In a real implementation, we'd update the passkey record)\n      \n      // Create session\n      const session = await sessionManager.createSession(user.id, res, {\n        ipAddress: req.ip,\n        userAgent: req.headers['user-agent'],\n      });\n      \n      res.json({\n        success: true,\n        codename: user.codename,\n        nearAccountId: user.nearAccountId,\n      });\n    } catch (error) {\n      console.error('[AnonAuth] Registration finish error:', error);\n      res.status(500).json({ error: 'Registration failed' });\n    }\n  });\n\n  // ============================================\n  // Authentication\n  // ============================================\n\n  /**\n   * POST /login/start\n   * Start passkey authentication\n   */\n  router.post('/login/start', async (req: Request, res: Response) => {\n    try {\n      const { codename } = req.body;\n      \n      let userId: string | undefined;\n      \n      if (codename) {\n        const user = await db.getUserByCodename(codename);\n        if (!user) {\n          return res.status(404).json({ error: 'User not found' });\n        }\n        userId = user.id;\n      }\n      \n      const { challengeId, options } = await passkeyManager.startAuthentication(userId);\n      \n      res.json({ challengeId, options });\n    } catch (error) {\n      console.error('[AnonAuth] Login start error:', error);\n      res.status(500).json({ error: 'Login failed' });\n    }\n  });\n\n  /**\n   * POST /login/finish\n   * Complete passkey authentication\n   */\n  router.post('/login/finish', async (req: Request, res: Response) => {\n    try {\n      const { challengeId, response } = req.body;\n      \n      if (!challengeId || !response) {\n        return res.status(400).json({ error: 'Missing required fields' });\n      }\n      \n      const { verified, userId } = await passkeyManager.finishAuthentication(\n        challengeId,\n        response\n      );\n      \n      if (!verified || !userId) {\n        return res.status(401).json({ error: 'Authentication failed' });\n      }\n      \n      const user = await db.getUserById(userId);\n      \n      if (!user) {\n        return res.status(404).json({ error: 'User not found' });\n      }\n      \n      // Create session\n      await sessionManager.createSession(user.id, res, {\n        ipAddress: req.ip,\n        userAgent: req.headers['user-agent'],\n      });\n      \n      res.json({\n        success: true,\n        codename: user.codename,\n      });\n    } catch (error) {\n      console.error('[AnonAuth] Login finish error:', error);\n      res.status(500).json({ error: 'Authentication failed' });\n    }\n  });\n\n  /**\n   * POST /logout\n   * End session\n   */\n  router.post('/logout', async (req: Request, res: Response) => {\n    try {\n      await sessionManager.destroySession(req, res);\n      res.json({ success: true });\n    } catch (error) {\n      console.error('[AnonAuth] Logout error:', error);\n      res.status(500).json({ error: 'Logout failed' });\n    }\n  });\n\n  /**\n   * GET /session\n   * Get current session\n   */\n  router.get('/session', async (req: Request, res: Response) => {\n    try {\n      const session = await sessionManager.getSession(req);\n      \n      if (!session) {\n        return res.status(401).json({ authenticated: false });\n      }\n      \n      const user = await db.getUserById(session.userId);\n      \n      if (!user) {\n        return res.status(401).json({ authenticated: false });\n      }\n      \n      res.json({\n        authenticated: true,\n        codename: user.codename,\n        nearAccountId: user.nearAccountId,\n        expiresAt: session.expiresAt,\n      });\n    } catch (error) {\n      console.error('[AnonAuth] Session check error:', error);\n      res.status(500).json({ error: 'Session check failed' });\n    }\n  });\n\n  // ============================================\n  // Wallet Recovery\n  // ============================================\n\n  if (walletRecovery) {\n    /**\n     * POST /recovery/wallet/link\n     * Link a NEAR wallet for recovery\n     */\n    router.post('/recovery/wallet/link', async (req: Request, res: Response) => {\n      try {\n        const session = await sessionManager.getSession(req);\n        \n        if (!session) {\n          return res.status(401).json({ error: 'Authentication required' });\n        }\n        \n        const { challenge: walletChallenge, expiresAt } = walletRecovery.generateLinkChallenge();\n        \n        // Store challenge for verification\n        await db.storeChallenge({\n          id: crypto.randomUUID(),\n          challenge: walletChallenge,\n          type: 'recovery',\n          userId: session.userId,\n          expiresAt,\n          metadata: { action: 'wallet-link' },\n        });\n        \n        res.json({\n          challenge: walletChallenge,\n          expiresAt: expiresAt.toISOString(),\n        });\n      } catch (error) {\n        console.error('[AnonAuth] Wallet link error:', error);\n        res.status(500).json({ error: 'Failed to initiate wallet link' });\n      }\n    });\n\n    /**\n     * POST /recovery/wallet/verify\n     * Verify wallet signature and complete linking\n     */\n    router.post('/recovery/wallet/verify', async (req: Request, res: Response) => {\n      try {\n        const session = await sessionManager.getSession(req);\n        \n        if (!session) {\n          return res.status(401).json({ error: 'Authentication required' });\n        }\n        \n        const { signature, challenge, walletAccountId } = req.body;\n        \n        if (!signature || !challenge || !walletAccountId) {\n          return res.status(400).json({ error: 'Missing required fields' });\n        }\n        \n        const { verified, walletId } = walletRecovery.verifyLinkSignature(\n          signature,\n          challenge\n        );\n        \n        if (!verified) {\n          return res.status(401).json({ error: 'Invalid signature' });\n        }\n        \n        const user = await db.getUserById(session.userId);\n        \n        if (!user) {\n          return res.status(404).json({ error: 'User not found' });\n        }\n        \n        // Add wallet as access key on-chain (no DB storage)\n        await mpcManager.addRecoveryWallet(user.nearAccountId, walletAccountId);\n        \n        // Store reference for our records (just the fact that wallet recovery is enabled)\n        await db.storeRecoveryData({\n          userId: user.id,\n          type: 'wallet',\n          reference: 'enabled', // We don't store the wallet ID!\n          createdAt: new Date(),\n        });\n        \n        res.json({\n          success: true,\n          message: 'Wallet linked for recovery. The link is stored on-chain, not in our database.',\n        });\n      } catch (error) {\n        console.error('[AnonAuth] Wallet verify error:', error);\n        res.status(500).json({ error: 'Failed to verify wallet' });\n      }\n    });\n\n    /**\n     * POST /recovery/wallet/start\n     * Start wallet-based recovery\n     */\n    router.post('/recovery/wallet/start', async (req: Request, res: Response) => {\n      try {\n        const { challenge, expiresAt } = walletRecovery.generateRecoveryChallenge();\n        \n        res.json({\n          challenge,\n          expiresAt: expiresAt.toISOString(),\n        });\n      } catch (error) {\n        console.error('[AnonAuth] Wallet recovery start error:', error);\n        res.status(500).json({ error: 'Failed to start recovery' });\n      }\n    });\n\n    /**\n     * POST /recovery/wallet/finish\n     * Complete wallet-based recovery\n     */\n    router.post('/recovery/wallet/finish', async (req: Request, res: Response) => {\n      try {\n        const { signature, challenge, nearAccountId } = req.body;\n        \n        if (!signature || !challenge || !nearAccountId) {\n          return res.status(400).json({ error: 'Missing required fields' });\n        }\n        \n        const { verified } = await walletRecovery.verifyRecoverySignature(\n          signature,\n          challenge,\n          nearAccountId\n        );\n        \n        if (!verified) {\n          return res.status(401).json({ error: 'Recovery verification failed' });\n        }\n        \n        // Find user by NEAR account\n        const user = await db.getUserByNearAccount(nearAccountId);\n        \n        if (!user) {\n          return res.status(404).json({ error: 'Account not found' });\n        }\n        \n        // Create session for recovered user\n        await sessionManager.createSession(user.id, res, {\n          ipAddress: req.ip,\n          userAgent: req.headers['user-agent'],\n        });\n        \n        res.json({\n          success: true,\n          codename: user.codename,\n          message: 'Recovery successful. You can now register a new passkey.',\n        });\n      } catch (error) {\n        console.error('[AnonAuth] Wallet recovery finish error:', error);\n        res.status(500).json({ error: 'Recovery failed' });\n      }\n    });\n  }\n\n  // ============================================\n  // IPFS Recovery\n  // ============================================\n\n  if (ipfsRecovery) {\n    /**\n     * POST /recovery/ipfs/setup\n     * Create encrypted backup on IPFS\n     */\n    router.post('/recovery/ipfs/setup', async (req: Request, res: Response) => {\n      try {\n        const session = await sessionManager.getSession(req);\n        \n        if (!session) {\n          return res.status(401).json({ error: 'Authentication required' });\n        }\n        \n        const { password } = req.body;\n        \n        if (!password) {\n          return res.status(400).json({ error: 'Password required' });\n        }\n        \n        // Validate password\n        const validation = ipfsRecovery.validatePassword(password);\n        if (!validation.valid) {\n          return res.status(400).json({\n            error: 'Password too weak',\n            details: validation.errors,\n          });\n        }\n        \n        const user = await db.getUserById(session.userId);\n        \n        if (!user) {\n          return res.status(404).json({ error: 'User not found' });\n        }\n        \n        // Create and pin backup\n        const { cid } = await ipfsRecovery.createRecoveryBackup(\n          {\n            userId: user.id,\n            nearAccountId: user.nearAccountId,\n            derivationPath: user.derivationPath,\n            createdAt: Date.now(),\n          },\n          password\n        );\n        \n        // Store CID reference\n        await db.storeRecoveryData({\n          userId: user.id,\n          type: 'ipfs',\n          reference: cid,\n          createdAt: new Date(),\n        });\n        \n        res.json({\n          success: true,\n          cid,\n          message: 'Backup created. Save this CID with your password - you need both to recover.',\n        });\n      } catch (error) {\n        console.error('[AnonAuth] IPFS setup error:', error);\n        res.status(500).json({ error: 'Failed to create backup' });\n      }\n    });\n\n    /**\n     * POST /recovery/ipfs/recover\n     * Recover using IPFS backup\n     */\n    router.post('/recovery/ipfs/recover', async (req: Request, res: Response) => {\n      try {\n        const { cid, password } = req.body;\n        \n        if (!cid || !password) {\n          return res.status(400).json({ error: 'CID and password required' });\n        }\n        \n        // Decrypt backup\n        let payload;\n        try {\n          payload = await ipfsRecovery.recoverFromBackup(cid, password);\n        } catch {\n          return res.status(401).json({ error: 'Invalid password or CID' });\n        }\n        \n        // Find user\n        const user = await db.getUserById(payload.userId);\n        \n        if (!user) {\n          return res.status(404).json({ error: 'Account not found' });\n        }\n        \n        // Create session\n        await sessionManager.createSession(user.id, res, {\n          ipAddress: req.ip,\n          userAgent: req.headers['user-agent'],\n        });\n        \n        res.json({\n          success: true,\n          codename: user.codename,\n          message: 'Recovery successful. You can now register a new passkey.',\n        });\n      } catch (error) {\n        console.error('[AnonAuth] IPFS recovery error:', error);\n        res.status(500).json({ error: 'Recovery failed' });\n      }\n    });\n  }\n\n  return router;\n}\n","/**\n * Server SDK Entry Point\n * \n * @example\n * ```typescript\n * import { createAnonAuth } from '@vitalpoint/near-phantom-auth/server';\n * \n * const anonAuth = createAnonAuth({\n *   nearNetwork: 'testnet',\n *   sessionSecret: process.env.SESSION_SECRET,\n *   database: {\n *     type: 'postgres',\n *     connectionString: process.env.DATABASE_URL,\n *   },\n *   rp: {\n *     name: 'My App',\n *     id: 'myapp.com',\n *     origin: 'https://myapp.com',\n *   },\n *   oauth: {\n *     callbackBaseUrl: 'https://myapp.com/auth/callback',\n *     google: { clientId: '...', clientSecret: '...' },\n *     github: { clientId: '...', clientSecret: '...' },\n *     twitter: { clientId: '...', clientSecret: '...' },\n *   },\n * });\n * \n * app.use('/auth', anonAuth.router);\n * app.use('/auth/oauth', anonAuth.oauthRouter);\n * app.get('/protected', anonAuth.requireAuth, handler);\n * ```\n */\n\nimport type { Router, RequestHandler } from 'express';\nimport type { AnonAuthConfig, DatabaseAdapter } from '../types/index.js';\nimport { createPostgresAdapter } from './db/adapters/postgres.js';\nimport { createSessionManager, type SessionManager } from './session.js';\nimport { createPasskeyManager, type PasskeyManager } from './passkey.js';\nimport { createMPCManager, type MPCAccountManager } from './mpc.js';\nimport { createWalletRecoveryManager, type WalletRecoveryManager } from './recovery/wallet.js';\nimport { createIPFSRecoveryManager, type IPFSRecoveryManager } from './recovery/ipfs.js';\nimport { createOAuthManager, type OAuthManager } from './oauth/index.js';\nimport { createOAuthRouter } from './oauth/router.js';\nimport { createAuthMiddleware, createRequireAuth } from './middleware.js';\nimport { createRouter } from './router.js';\n\nexport interface AnonAuthInstance {\n  /** Express router with all auth endpoints (passkey) */\n  router: Router;\n  \n  /** OAuth router for OAuth providers */\n  oauthRouter?: Router;\n  \n  /** Middleware that attaches user to request if authenticated */\n  middleware: RequestHandler;\n  \n  /** Middleware that requires authentication (401 if not) */\n  requireAuth: RequestHandler;\n  \n  /** Initialize database schema */\n  initialize(): Promise<void>;\n  \n  /** Database adapter */\n  db: DatabaseAdapter;\n  \n  /** Session manager */\n  sessionManager: SessionManager;\n  \n  /** Passkey manager */\n  passkeyManager: PasskeyManager;\n  \n  /** MPC account manager */\n  mpcManager: MPCAccountManager;\n  \n  /** Wallet recovery manager (if enabled) */\n  walletRecovery?: WalletRecoveryManager;\n  \n  /** IPFS recovery manager (if enabled) */\n  ipfsRecovery?: IPFSRecoveryManager;\n  \n  /** OAuth manager (if enabled) */\n  oauthManager?: OAuthManager;\n}\n\n/**\n * Create anonymous authentication instance\n */\nexport function createAnonAuth(config: AnonAuthConfig): AnonAuthInstance {\n  // Create database adapter\n  let db: DatabaseAdapter;\n  \n  if (config.database.adapter) {\n    db = config.database.adapter;\n  } else if (config.database.type === 'postgres') {\n    if (!config.database.connectionString) {\n      throw new Error('PostgreSQL requires connectionString');\n    }\n    db = createPostgresAdapter({\n      connectionString: config.database.connectionString,\n    });\n  } else if (config.database.type === 'custom') {\n    if (!config.database.adapter) {\n      throw new Error('Custom database type requires adapter');\n    }\n    db = config.database.adapter;\n  } else {\n    throw new Error(`Unsupported database type: ${config.database.type}`);\n  }\n\n  // Create session manager\n  const sessionManager = createSessionManager(db, {\n    secret: config.sessionSecret,\n    durationMs: config.sessionDurationMs,\n  });\n\n  // Create passkey manager\n  const rpConfig = config.rp || {\n    name: 'Anonymous Auth',\n    id: 'localhost',\n    origin: 'http://localhost:3000',\n  };\n\n  const passkeyManager = createPasskeyManager(db, {\n    rpName: rpConfig.name,\n    rpId: rpConfig.id,\n    origin: rpConfig.origin,\n  });\n\n  // Create MPC manager\n  const mpcManager = createMPCManager({\n    networkId: config.nearNetwork,\n    accountPrefix: config.mpc?.accountPrefix || 'anon',\n    treasuryAccount: config.mpc?.treasuryAccount,\n    treasuryPrivateKey: config.mpc?.treasuryPrivateKey,\n    fundingAmount: config.mpc?.fundingAmount,\n  });\n\n  // Create recovery managers\n  let walletRecovery: WalletRecoveryManager | undefined;\n  let ipfsRecovery: IPFSRecoveryManager | undefined;\n\n  if (config.recovery?.wallet) {\n    walletRecovery = createWalletRecoveryManager({\n      nearNetwork: config.nearNetwork,\n    });\n  }\n\n  if (config.recovery?.ipfs) {\n    ipfsRecovery = createIPFSRecoveryManager(config.recovery.ipfs);\n  }\n\n  // Create OAuth manager and router\n  let oauthManager: OAuthManager | undefined;\n  let oauthRouter: Router | undefined;\n\n  if (config.oauth) {\n    oauthManager = createOAuthManager(\n      {\n        google: config.oauth.google,\n        github: config.oauth.github,\n        twitter: config.oauth.twitter,\n      },\n      db\n    );\n\n    oauthRouter = createOAuthRouter({\n      db,\n      sessionManager,\n      mpcManager,\n      oauthConfig: config.oauth,\n      ipfsRecovery,\n    });\n  }\n\n  // Create middleware\n  const middleware = createAuthMiddleware(sessionManager, db);\n  const requireAuth = createRequireAuth(sessionManager, db);\n\n  // Create router (passkey auth)\n  const router = createRouter({\n    db,\n    sessionManager,\n    passkeyManager,\n    mpcManager,\n    walletRecovery,\n    ipfsRecovery,\n    codename: config.codename,\n  });\n\n  return {\n    router,\n    oauthRouter,\n    middleware,\n    requireAuth,\n    \n    async initialize() {\n      await db.initialize();\n    },\n    \n    db,\n    sessionManager,\n    passkeyManager,\n    mpcManager,\n    walletRecovery,\n    ipfsRecovery,\n    oauthManager,\n  };\n}\n\n// Re-export types and utilities\nexport type { \n  AnonAuthConfig, \n  DatabaseAdapter, \n  AnonUser, \n  OAuthUser,\n  User,\n  UserType,\n  OAuthProvider,\n  OAuthConfig,\n  Session \n} from '../types/index.js';\nexport type { SessionManager, SessionConfig } from './session.js';\nexport type { PasskeyManager, PasskeyConfig } from './passkey.js';\nexport type { MPCAccountManager, MPCConfig, MPCAccount } from './mpc.js';\nexport type { WalletRecoveryManager } from './recovery/wallet.js';\nexport type { IPFSRecoveryManager, IPFSRecoveryConfig } from './recovery/ipfs.js';\nexport type { OAuthManager, OAuthProfile, OAuthTokens, OAuthProviderConfig } from './oauth/index.js';\nexport { generateCodename, isValidCodename } from './codename.js';\nexport { createPostgresAdapter, POSTGRES_SCHEMA } from './db/adapters/postgres.js';\nexport { createOAuthManager } from './oauth/index.js';\nexport { createOAuthRouter } from './oauth/router.js';\n"]}